<!DOCTYPE html>
<html lang="en">
  <head>
    <title>16570 &ndash; Compare refuses to show further differences if not ignoring whitespaces</title>

      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<link href="https://bugs.eclipse.org/bugs/data/assets/03c4bb46b12126a79867f9a9f5323634.css?1593441374" rel="stylesheet" type="text/css">



    
<script type="text/javascript" src="https://bugs.eclipse.org/bugs/data/assets/a7c2f3a028f17a9aa60f56dc9d6e732d.js?1593441374"></script>

    <script type="text/javascript">
    <!--
        YAHOO.namespace('bugzilla');
        YAHOO.util.Event.addListener = function (el, sType, fn, obj, overrideContext) {
               if ( ("onpagehide" in window || YAHOO.env.ua.gecko) && sType === "unload") { sType = "pagehide"; };
               var capture = ((sType == "focusin" || sType == "focusout") && !YAHOO.env.ua.ie) ? true : false;
               return this._addListener(el, this._getType(sType), fn, obj, overrideContext, capture);
         };
        if ( "onpagehide" in window || YAHOO.env.ua.gecko) {
            YAHOO.util.Event._simpleRemove(window, "unload", 
                                           YAHOO.util.Event._unload);
        }
        
        function unhide_language_selector() { 
            YAHOO.util.Dom.removeClass(
                'lang_links_container', 'bz_default_hidden'
            ); 
        } 
        YAHOO.util.Event.onDOMReady(unhide_language_selector);

        
        var BUGZILLA = {
            param: {
                cookiepath: '\/bugs',
                maxusermatches: 10
            },
            constant: {
                COMMENT_COLS: 80
            },
            string: {
                

                attach_desc_required:
                    "You must enter a Description for this attachment.",
                component_required:
                    "You must select a Component for this bug.",
                description_required:
                    "You must enter a Description for this bug.",
                short_desc_required:
                    "You must enter a Summary for this bug.",
                version_required:
                    "You must select a Version for this bug."
            }
              , api_token: ''
        };

    if (history && history.replaceState) {
      if(!document.location.href.match(/show_bug\.cgi/)) {
        history.replaceState( null,
                             "16570 – Compare refuses to show further differences if not ignoring whitespaces",
                             "show_bug.cgi?id=16570" );
        document.title = "16570 – Compare refuses to show further differences if not ignoring whitespaces";
      }
      if (document.location.href.match(/show_bug\.cgi\?.*list_id=/)) {
        var href = document.location.href;
        href = href.replace(/[\?&]+list_id=(\d+|cookie)/, '');
        history.replaceState(null, "16570 – Compare refuses to show further differences if not ignoring whitespaces", href);
      }
    }
    YAHOO.util.Event.onDOMReady(function() {
      initDirtyFieldTracking();

    });
    // -->
    </script>
<script type="text/javascript" src="https://bugs.eclipse.org/bugs/data/assets/daf5e0fb6826e6a35280e622913f0c4a.js?1593441374"></script>

    

    
    <link rel="search" type="application/opensearchdescription+xml"
                       title="Bugzilla" href="./search_plugin.cgi">
    <link rel="shortcut icon" href="images/favicon.ico">
  </head>

  <body 
        class="bugs-eclipse-org-bugs
                 bz_bug
                 bz_status_RESOLVED
                 bz_product_Platform
                 bz_component_Compare
                 bz_bug_16570 yui-skin-sam">

  <div id="header"><!-- 1.0@bugzilla.org -->





<!--  START OF SOLSTICE HEADER -->
 <link rel="stylesheet" type="text/css" href="https://www.eclipse.org/eclipse.org-common/themes/solstice/public/stylesheets/vendor/cookieconsent/cookieconsent.min.css" />
 <script src="https://www.eclipse.org/eclipse.org-common/themes/solstice/public/javascript/vendor/cookieconsent/default.min.js"></script>
 <style type="text/css">
    @import url('https://www.eclipse.org/eclipse.org-common/themes/solstice/public/stylesheets/barebone.min.css')
    </style>
    <script
      src="https://www.eclipse.org/eclipse.org-common/themes/solstice/public/javascript/barebone.min.js">
    </script><header role="banner" class="barebone-layout thin-header padding-top-5 padding-bottom-5"  id="header-wrapper">
  <div class="container-fluid reset">
    <div class="row-fluid" id="header-row">
            <div class="col-sm-8 col-md-6 col-lg-4" id="header-left">
        <div class="wrapper-logo-default"><a href="https://www.eclipse.org/"><img class="logo-eclipse-default img-responsive hidden-xs" alt="logo" src="https://bugs.eclipse.org/eclipse.org-common/themes/solstice/public/images/logo/eclipse-426x100.png"/></a></div>
      </div>            <div class="col-sm-16 col-md-18 col-lg-20" id="main-menu-wrapper">
  <div class="navbar yamm" id="main-menu">
    <div id="navbar-collapse-1" class="navbar-collapse collapse">
      <ul class="nav navbar-nav navbar-right">
        <li class="visible-thin"><a href="https://www.eclipse.org/downloads/" target="_self">Download</a></li><li><a href="https://www.eclipse.org/users/" target="_self">Getting Started</a></li><li><a href="https://www.eclipse.org/membership/" target="_self">Members</a></li><li><a href="https://www.eclipse.org/projects/" target="_self">Projects</a></li>                  <li class="dropdown visible-xs"><a href="#" data-toggle="dropdown" class="dropdown-toggle">Community <b class="caret"></b></a><ul class="dropdown-menu"><li><a href="http://marketplace.eclipse.org">Marketplace</a></li><li><a href="http://events.eclipse.org">Events</a></li><li><a href="http://www.planeteclipse.org/">Planet Eclipse</a></li><li><a href="https://www.eclipse.org/community/eclipse_newsletter/">Newsletter</a></li><li><a href="https://www.youtube.com/user/EclipseFdn">Videos</a></li></ul></li><li class="dropdown visible-xs"><a href="#" data-toggle="dropdown" class="dropdown-toggle">Participate <b class="caret"></b></a><ul class="dropdown-menu"><li><a href="https://bugs.eclipse.org/bugs/">Report a Bug</a></li><li><a href="https://www.eclipse.org/forums/">Forums</a></li><li><a href="https://www.eclipse.org/mail/">Mailing Lists</a></li><li><a href="https://wiki.eclipse.org/">Wiki</a></li><li><a href="https://wiki.eclipse.org/IRC">IRC</a></li><li><a href="https://www.eclipse.org/contribute/">How to Contribute</a></li></ul></li><li class="dropdown visible-xs"><a href="#" data-toggle="dropdown" class="dropdown-toggle">Working Groups <b class="caret"></b></a><ul class="dropdown-menu"><li><a href="http://wiki.eclipse.org/Auto_IWG">Automotive</a></li><li><a href="http://iot.eclipse.org">Internet of Things</a></li><li><a href="http://locationtech.org">LocationTech</a></li><li><a href="http://lts.eclipse.org">Long-Term Support</a></li><li><a href="http://polarsys.org">PolarSys</a></li><li><a href="http://science.eclipse.org">Science</a></li><li><a href="http://www.openmdm.org">OpenMDM</a></li></ul></li>          <!-- More -->
          <li class="dropdown eclipse-more hidden-xs">
            <a data-toggle="dropdown" class="dropdown-toggle">More<b class="caret"></b></a>
            <ul class="dropdown-menu">
              <li>
                <!-- Content container to add padding -->
                <div class="yamm-content">
                  <div class="row">
                    <ul class="col-sm-8 list-unstyled"><li><p><strong>Community</strong></p></li><li><a href="http://marketplace.eclipse.org">Marketplace</a></li><li><a href="http://events.eclipse.org">Events</a></li><li><a href="http://www.planeteclipse.org/">Planet Eclipse</a></li><li><a href="https://www.eclipse.org/community/eclipse_newsletter/">Newsletter</a></li><li><a href="https://www.youtube.com/user/EclipseFdn">Videos</a></li></ul><ul class="col-sm-8 list-unstyled"><li><p><strong>Participate</strong></p></li><li><a href="https://bugs.eclipse.org/bugs/">Report a Bug</a></li><li><a href="https://www.eclipse.org/forums/">Forums</a></li><li><a href="https://www.eclipse.org/mail/">Mailing Lists</a></li><li><a href="https://wiki.eclipse.org/">Wiki</a></li><li><a href="https://wiki.eclipse.org/IRC">IRC</a></li><li><a href="https://www.eclipse.org/contribute/">How to Contribute</a></li></ul><ul class="col-sm-8 list-unstyled"><li><p><strong>Working Groups</strong></p></li><li><a href="http://wiki.eclipse.org/Auto_IWG">Automotive</a></li><li><a href="http://iot.eclipse.org">Internet of Things</a></li><li><a href="http://locationtech.org">LocationTech</a></li><li><a href="http://lts.eclipse.org">Long-Term Support</a></li><li><a href="http://polarsys.org">PolarSys</a></li><li><a href="http://science.eclipse.org">Science</a></li><li><a href="http://www.openmdm.org">OpenMDM</a></li></ul>                  </div>
                </div>
              </li>
            </ul>
          </li>
              </ul>
    </div>
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse-1">
      <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      </button>
      <div class="wrapper-logo-mobile"><a class="navbar-brand visible-xs" href="https://www.eclipse.org/"><img class="logo-eclipse-default-mobile img-responsive" alt="logo" src="https://bugs.eclipse.org/eclipse.org-common/themes/solstice/public/images/logo/eclipse-800x188.png"/></a></div>    </div>
  </div>
</div>
    </div>
  </div>
</header>
<!--  END OF SOLSTICE HEADER -->

    <div id="titles">
      <span id="title">Bugzilla &ndash; Bug&nbsp;16570</span>

        <span id="subtitle" class="subheader">Compare refuses to show further differences if not ignoring whitespaces</span>

        <span id="information" class="header_addl_info">Last modified: 2003-02-10 08:54:16 EST</span>
    </div>


    <div id="common_links"><ul class="links">
  <li><a href="./">Home</a></li>
  <li><span class="separator">| </span><a href="enter_bug.cgi">New</a></li>
  <li><span class="separator">| </span><a href="describecomponents.cgi">Browse</a></li>
  <li><span class="separator">| </span><a href="query.cgi">Search</a></li>

  <li class="form">
    <span class="separator">| </span>
    <form action="buglist.cgi" method="get"
        onsubmit="if (this.quicksearch.value == '')
                  { alert('Please enter one or more search terms first.');
                    return false; } return true;">
    <input type="hidden" id="no_redirect_top" name="no_redirect" value="0">
    <script type="text/javascript">
      if (history && history.replaceState) {
        var no_redirect = document.getElementById("no_redirect_top");
        no_redirect.value = 1;
      }
    </script>
    <input class="txt" type="text" id="quicksearch_top" name="quicksearch" 
           title="Quick Search" value="">
    <input class="btn" type="submit" value="Search" 
           id="find_top"></form>
  <a href="page.cgi?id=quicksearch.html" title="Quicksearch Help">[?]</a></li>

  <li><span class="separator">| </span><a href="report.cgi">Reports</a></li>

  <li>
      <span class="separator">| </span>
        <a href="request.cgi">Requests</a></li>


  <li>
        <span class="separator">| </span>
        <a href="https://bugzilla.readthedocs.org/en/5.0/using/understanding.html" target="_blank">Help</a>
      </li>
    

    <li id="mini_login_container_top">
  <span class="separator">| </span>
  <a id="login_link_top" href="show_bug.cgi?id=16570&amp;GoAheadAndLogIn=1"
     onclick="return show_mini_login_form('_top')">Log In</a>

  <form action="show_bug.cgi?id=16570" method="POST"
        class="mini_login bz_default_hidden"
        id="mini_login_top">
    <input id="Bugzilla_login_top" required
           name="Bugzilla_login" class="bz_login"
        placeholder="Login">
    <input class="bz_password" name="Bugzilla_password" type="password"
           id="Bugzilla_password_top" required
           placeholder="Password">
    <input type="hidden" name="Bugzilla_login_token"
           value="">
    <input type="submit" name="GoAheadAndLogIn" value="Log in"
            id="log_in_top">
    <a href="#" onclick="return hide_mini_login_form('_top')">[x]</a>
  </form>
</li>
  <span class="separator">| </span>
  <li><a href="http://www.eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
  <span class="separator">| </span>
  <li><a href="http://www.eclipse.org/legal/copyright.php">Copyright Agent</a></li>
</ul>
    </div>
  </div>

  <div id="bugzilla-body">


<script type="text/javascript">
<!--

//-->
</script>

<form name="changeform" id="changeform" method="post" action="process_bug.cgi">

  <input type="hidden" name="delta_ts" value="2003-02-10 08:54:16">
  <input type="hidden" name="id" value="16570">
  <input type="hidden" name="token" value="1629868671-RRdBM_KMw132P50XNHi75u2o5CbLeeU6itynoQ3nDic">
<div class="bz_short_desc_container edit_form">
     <a href="show_bug.cgi?id=16570"><b>Bug&nbsp;16570</b></a> <span id="summary_container" class="bz_default_hidden">
      - <span id="short_desc_nonedit_display">Compare refuses to show further differences if not ignoring whitespaces</span>
     </span>

    <div id="summary_input"><span class="field_label "
    id="field_label_short_desc">


  <a 
      title="The bug summary is a short sentence which succinctly describes what the bug is about."
      class="field_help_link"
      href="page.cgi?id=fields.html#short_desc"
  >Summary:</a>

</span>Compare refuses to show further differences if not ignoring whitespaces
    </div>
  </div>
  <script type="text/javascript">
    hideEditableField('summary_container',
                      'summary_input',
                      'summary_edit_action',
                      'short_desc',
                      'Compare refuses to show further differences if not ignoring whitespaces' );
  </script>
  <table class="edit_form">
    <tr>
      
      <td id="bz_show_bug_column_1" class="bz_show_bug_column">     
        <table>
          <tr>
    <th class="field_label">
      <a href="page.cgi?id=fields.html#bug_status">Status</a>:
    </th>
    <td id="bz_field_status">
      <span id="static_bug_status">RESOLVED
          FIXED
      </span>
    </td>
  </tr>
<tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>
<tr><th class="field_label "
    id="field_label_alias">


  <a 
      title="A short, unique name assigned to a bug in order to assist with looking it up and referring to it in other places in Bugzilla."
      class="field_help_link"
      href="page.cgi?id=fields.html#alias"
  >Alias:</a>

</th>
    <td>
        None
    </td>
  </tr>
<tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>
<tr><th class="field_label "
    id="field_label_product">


  <a 
      title="Bugs are categorised into Products and Components. Select a Classification to narrow down this list."
      class="field_help_link"
      href="describecomponents.cgi"
  >Product:</a>

</th>
  <td class="field_value "
      id="field_container_product" >Platform

</td>
    </tr>

    
    <tr class="bz_default_hidden"><th class="field_label "
    id="field_label_classification">


  <a 
      title="Bugs are categorised into Classifications, Products and Components. classifications is the top-level categorisation."
      class="field_help_link"
      href="page.cgi?id=fields.html#classification"
  >Classification:</a>

</th>
  <td class="field_value "
      id="field_container_classification" >Eclipse Project

</td>
    </tr>
        
    
    
    <tr><th class="field_label "
    id="field_label_component">


  <a 
      title="Components are second-level categories; each belongs to a particular Product. Select a Product to narrow down this list."
      class="field_help_link"
      href="describecomponents.cgi?product=Platform"
  >Component:</a>

</th>
  <td class="field_value "
      id="field_container_component" >Compare

  (<a href="buglist.cgi?component=Compare&amp;product=Platform&amp;bug_status=__open__"
      target="_blank">show other bugs</a>)
</td>
    </tr>
    <tr><th class="field_label "
    id="field_label_version">


  <a 
      title="The version field defines the version of the software the bug was found in."
      class="field_help_link"
      href="page.cgi?id=fields.html#version"
  >Version:</a>

</th>

      <td>2.0 &#160; <a href="https://dev.eclipse.org/committers/bugs/bugz_manager.php"><img src="//dev.eclipse.org/small_icons/apps/accessories-text-editor.png" alt="Edit" title="Edit these values" /></a></td>
    </tr>
        
    
        
    <tr><th class="field_label "
    id="field_label_rep_platform">


  <a 
      title="The hardware platform the bug was observed on. Note: When searching, selecting the option &quot;All&quot; only finds bugs whose value for this field is literally the word &quot;All&quot;."
      class="field_help_link"
      href="page.cgi?id=fields.html#rep_platform"
  >Hardware:</a>

</th>
      <td class="field_value">PC
        Windows 2000
      </td>
    </tr>
          <tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>
          
          <tr>
      <th class="field_label">
        <label  accesskey="i">
          <a href="page.cgi?id=fields.html#importance"><u>I</u>mportance</a></label>:
      </th>
      <td>P3
       normal<span id="votes_container">
    (<a href="page.cgi?id=voting/user.html&amp;bug_id=16570#vote_16570">vote</a>)
  </span>
      </td>
    </tr>

      <tr><th class="field_label "
    id="field_label_target_milestone">


  <a 
      title="The Target Milestone field is used to define when the engineer the bug is assigned to expects to fix it."
      class="field_help_link"
      href="page.cgi?id=fields.html#target_milestone"
  >Target Milestone:</a>

</th>
        <td>2.0 F2 &#160; <a href="https://dev.eclipse.org/committers/bugs/bugz_manager.php"><img src="//dev.eclipse.org/small_icons/apps/accessories-text-editor.png" alt="Edit" title="Edit these values" /></a></td>
      </tr>
          
          <tr><th class="field_label "
    id="field_label_assigned_to">


  <a 
      title="The person in charge of resolving the bug."
      class="field_help_link"
      href="page.cgi?id=fields.html#assigned_to"
  >Assignee:</a>

</th>
      <td><span class="vcard"><span class="fn">Philipe Mulet</span> <a href="http://wiki.eclipse.org/ECA"><img class="cla_dec" src="https://accounts.eclipse.org/user/eca/badge?mail=philippe_mulet&#64;fr.ibm.com" alt="CLA" title="Eclipse Contributor Agreement" /></a> <a href="https://eclipse.org/donate/"><img class="cla_dec" src="//www.eclipse.org/donate/web-api/friends_decorator.php?email=philippe_mulet&#64;fr.ibm.com" alt="Friend" title="Friend of Eclipse" /></a>
</span>
      </td>
    </tr>

    <tr><th class="field_label "
    id="field_label_qa_contact">


  <a 
      title="The person responsible for confirming this bug if it is unconfirmed, and for verifying the fix once the bug has been resolved."
      class="field_help_link"
      href="page.cgi?id=fields.html#qa_contact"
  >QA Contact:</a>

</th>
      <td><span class="vcard">
</span>
      </td>
    </tr>
    <script type="text/javascript">
      assignToDefaultOnChange(['product', 'component'],
        'platform-compare-inbox\x40eclipse.org',
        '');
    </script>
          <tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>
          <tr><th class="field_label "
    id="field_label_bug_file_loc">


  <a 
      title="Bugs can have a URL associated with them - for example, a pointer to a web site where the problem is seen."
      class="field_help_link"
      href="page.cgi?id=fields.html#bug_file_loc"
  >URL:</a>

</th>
    <td>
      <span id="bz_url_input_area">
      </span>
    </td>
  </tr>

    <tr><th class="field_label "
    id="field_label_status_whiteboard">


  <a 
      title="Each bug has a free-form single line text entry box for adding tags and status information."
      class="field_help_link"
      href="page.cgi?id=fields.html#status_whiteboard"
  >Whiteboard:</a>

</th><td>  
  </td>
    </tr>

    <tr><th class="field_label "
    id="field_label_keywords">


  <a 
      title="You can add keywords from a defined list to bugs, in order to easily identify and group them."
      class="field_help_link"
      href="describekeywords.cgi"
  >Keywords:</a>

</th>
  <td class="field_value "
      id="field_container_keywords" >

</td>
    </tr>
          <tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>

          
<tr><th class="field_label "
    id="field_label_dependson">


  <a 
      title="The bugs listed here must be resolved before this bug can be resolved."
      class="field_help_link"
      href="page.cgi?id=fields.html#dependson"
  >Depends on:</a>

</th>

  <td>
    <span id="dependson_input_area">
    </span>

  </td>
  </tr>
  
  <tr><th class="field_label "
    id="field_label_blocked">


  <a 
      title="This bug must be resolved before the bugs listed in this field can be resolved."
      class="field_help_link"
      href="page.cgi?id=fields.html#blocked"
  >Blocks:</a>

</th>

  <td>
    <span id="blocked_input_area">
    </span>

  </td>
  </tr>
          
        </table>
      </td>
      <td>
        <div class="bz_column_spacer">&nbsp;</div>
      </td>
      
      <td id="bz_show_bug_column_2" class="bz_show_bug_column">
        <table>
        <tr>
    <th class="field_label">
      Reported:
    </th>
    <td>2002-05-21 10:43 EDT by <span class="vcard"><span class="fn">Philipe Mulet</span> <a href="http://wiki.eclipse.org/ECA"><img class="cla_dec" src="https://accounts.eclipse.org/user/eca/badge?mail=philippe_mulet&#64;fr.ibm.com" alt="CLA" title="Eclipse Contributor Agreement" /></a> <a href="https://eclipse.org/donate/"><img class="cla_dec" src="//www.eclipse.org/donate/web-api/friends_decorator.php?email=philippe_mulet&#64;fr.ibm.com" alt="Friend" title="Friend of Eclipse" /></a>
</span>
    </td>
  </tr>
  
  <tr>
    <th class="field_label">
      Modified:
    </th>
    <td>2003-02-10 08:54 EST
      (<a href="show_activity.cgi?id=16570">History</a>)
    </td>
  
  </tr>
<tr>
      <th class="field_label">
        <label  accesskey="a">
          CC List:
        </label>
      </th>
      <td>0 
          users
        <div id="cc_edit_area">
          <br>
        </div>
      </td>
    </tr>

<tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>
<tr><th class="field_label "
    id="field_label_see_also">


  <a 
      title="This allows you to refer to bugs in other installations. You can enter a URL to a bug in the 'Add Bug URLs' field to note that that bug is related to this one. You can enter multiple URLs at once by separating them with whitespace. You should normally use this field to refer to bugs in other installations. For bugs in this installation, it is better to use the Depends on and Blocks fields."
      class="field_help_link"
      href="page.cgi?id=fields.html#see_also"
  >See Also:</a>

</th>
  <td class="field_value "
      id="field_container_see_also" >

</td>
    </tr> 

<tr>
    <td colspan="2" class="bz_section_spacer"></td>
  </tr>



        </table>
      </td>
    </tr>
    <tr>
      <td colspan="3">
          <hr id="bz_top_half_spacer">
      </td>
    </tr>
  </table>

  <table id="bz_big_form_parts">
  <tr>
  <td>

    
<script type="text/javascript">
<!--
function toggle_display(link) {
    var table = document.getElementById("attachment_table");
    var view_all = document.getElementById("view_all");
    var hide_obsolete_url_parameter = "&hide_obsolete=1";
    // Store current height for scrolling later
    var originalHeight = table.offsetHeight;
    var rows = YAHOO.util.Dom.getElementsByClassName(
        'bz_tr_obsolete', 'tr', table);

    for (var i = 0; i < rows.length; i++) {
        bz_toggleClass(rows[i], 'bz_default_hidden');
    }

    if (YAHOO.util.Dom.hasClass(rows[0], 'bz_default_hidden')) {
        link.innerHTML = "Show Obsolete";
        view_all.href = view_all.href + hide_obsolete_url_parameter 
    }
    else {
        link.innerHTML = "Hide Obsolete";
        view_all.href = view_all.href.replace(hide_obsolete_url_parameter,"");
    }

    var newHeight = table.offsetHeight;
    // This scrolling makes the window appear to not move at all.
    window.scrollBy(0, newHeight - originalHeight);

    return false;
}
//-->
</script>

<br>
<table id="attachment_table">
  <tr id="a0">
    <th colspan="3" class="left">
      Attachments
    </th>
  </tr>



  <tr class="bz_attach_footer">
    <td colspan="3">
        <a href="attachment.cgi?bugid=16570&amp;action=enter">Add an attachment</a>
        (proposed patch, testcase, etc.)
    </td>
  </tr>
</table>
<br>
<div id="add_comment" class="bz_section_additional_comments">
      <table>
        <tr>
          <td>
            <fieldset>
              <legend>Note</legend>
              You need to
              <a href="show_bug.cgi?id=16570&amp;GoAheadAndLogIn=1">log in</a>
              before you can comment on or make changes to this bug.
            </fieldset>
          </td>
        </tr> 
      </table>
  </div>
  </td>
  <td>
  </td>
  </tr></table>

  
  <div id="comments"><script src="https://bugs.eclipse.org/bugs/js/comments.js?1463425338" type="text/javascript">
</script>

<script type="text/javascript">
<!--
  /* Adds the reply text to the 'comment' textarea */
  function replyToComment(id, real_id, name) {
      var prefix = "(In reply to " + name + " from comment #" + id + ")\n";
      var replytext = "";
        /* pre id="comment_name_N" */
        var text_elem = document.getElementById('comment_text_'+id);
        var text = getText(text_elem);
        replytext = prefix + wrapReplyText(text);


      /* <textarea id="comment"> */
      var textarea = document.getElementById('comment');
      if (textarea.value != replytext) {
          textarea.value += replytext;
      }

      textarea.focus();
  } 
//-->
</script>


<!-- This auto-sizes the comments and positions the collapse/expand links 
     to the right. -->
<table class="bz_comment_table">
<tr>
<td>
<div id="c0" class="bz_comment bz_first_comment">

      <div class="bz_first_comment_head">


        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=16570#c0">Description</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philipe Mulet</span> <a href="http://wiki.eclipse.org/ECA"><img class="cla_dec" src="https://accounts.eclipse.org/user/eca/badge?mail=philippe_mulet&#64;fr.ibm.com" alt="CLA" title="Eclipse Contributor Agreement" /></a> <a href="https://eclipse.org/donate/"><img class="cla_dec" src="//www.eclipse.org/donate/web-api/friends_decorator.php?email=philippe_mulet&#64;fr.ibm.com" alt="Friend" title="Friend of Eclipse" /></a>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2002-05-21 10:43:28 EDT
        </span>

      </div>




<pre class="bz_comment_text">Build 20020519

When synchronizing a change on a file which contains an indentation change 
(using TABs), the compare view refuses to step to the next change. Though it 
indicates it has more changes (from the annotations in the scrollbar on the 
right).

If activating the option 'ignore whitespaces' then it works ok again.</pre>
    </div>

    <div id="c1" class="bz_comment">

      <div class="bz_comment_head">


        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=16570#c1">Comment 1</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philipe Mulet</span> <a href="http://wiki.eclipse.org/ECA"><img class="cla_dec" src="https://accounts.eclipse.org/user/eca/badge?mail=philippe_mulet&#64;fr.ibm.com" alt="CLA" title="Eclipse Contributor Agreement" /></a> <a href="https://eclipse.org/donate/"><img class="cla_dec" src="//www.eclipse.org/donate/web-api/friends_decorator.php?email=philippe_mulet&#64;fr.ibm.com" alt="Friend" title="Friend of Eclipse" /></a>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2002-05-21 10:44:23 EDT
        </span>

      </div>




<pre class="bz_comment_text">Source before: 
[/******************************************************************************
*
 * Copyright (c) 2000, 2001, 2002 International Business Machines Corp. and 
others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v0.5 
 * which accompanies this distribution, and is available at
 * <a href="http://www.eclipse.org/legal/cpl-v05.html">http://www.eclipse.org/legal/cpl-v05.html</a>
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 ******************************************************************************/
package org.eclipse.jdt.internal.core;

import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceChangeEvent;
import org.eclipse.core.resources.IResourceChangeListener;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.QualifiedName;
import org.eclipse.jdt.core.ElementChangedEvent;
import org.eclipse.jdt.core.IClasspathEntry;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IJavaElementDelta;
import org.eclipse.jdt.core.IJavaModel;
import org.eclipse.jdt.core.IJavaModelStatusConstants;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IPackageFragment;
import org.eclipse.jdt.core.IPackageFragmentRoot;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.internal.core.search.indexing.IndexManager;

/**
 * This class is used by &lt;code&gt;JavaModelManager&lt;/code&gt; to convert
 * &lt;code&gt;IResourceDelta&lt;/code&gt;s into &lt;code&gt;IJavaElementDelta&lt;/code&gt;s.
 * It also does some processing on the &lt;code&gt;JavaElement&lt;/code&gt;s involved
 * (e.g. closing them or updating classpaths).
 */
public class DeltaProcessor implements IResourceChangeListener {
	
	final static int IGNORE = 0;
	final static int SOURCE = 1;
	final static int BINARY = 2;
	
	/**
	 * The &lt;code&gt;JavaElementDelta&lt;/code&gt; corresponding to the 
&lt;code&gt;IResourceDelta&lt;/code&gt; being translated.
	 */
	protected JavaElementDelta fCurrentDelta;

	protected IndexManager indexManager = new IndexManager();
		
	/* A table from IPath (from a classpath entry) to IJavaProject */
	Map roots;
	
	/* A table from IPath (from a classpath entry) to HashSet of 
IJavaProject
	 * Used when an IPath corresponds to more than one root */
	Map otherRoots;
	
	/* The java element that was last created (see createElement
(IResource). 
	 * This is used as a stack of java elements (using getParent() to pop 
it, and 
	 * using the various get*(...) to push it. */
	Openable currentElement;
	
	/*
	 * The type of the current event being processed (see 
ChangedElementEvent)
	 */
	int currentEventType;
	
	public HashSet projectsToUpdate = new HashSet();
	public HashSet externalJarPathsToUpdate = new HashSet();
	
	JavaModelManager manager;

	static final IJavaElementDelta[] NO_DELTA = new IJavaElementDelta[0];

	public static boolean VERBOSE = false;

	DeltaProcessor(JavaModelManager manager) {
		this.manager = manager;
	}

	/*
	 * Adds the dependents of the given project to the list of the projects
	 * to update.
	 */
	void addDependentsToProjectsToUpdate(IPath projectPath) {
		try {
			IJavaProject[] projects = 
JavaModelManager.getJavaModelManager().getJavaModel().getJavaProjects();
			for (int i = 0, length = projects.length; i &lt; length; 
i++) {
				IJavaProject project = projects[i];
				IClasspathEntry[] classpath = 
project.getResolvedClasspath(true);
				for (int j = 0, length2 = classpath.length; j &lt; 
length2; j++) {
					IClasspathEntry entry = classpath[j];
					if (entry.getEntryKind() == 
IClasspathEntry.CPE_PROJECT
							&amp;&amp; entry.getPath
().equals(projectPath)) {
						this.projectsToUpdate.add
(project);
					}
				}
			}
		} catch (JavaModelException e) {
		}
	}
	/*
	 * Adds the given project and its dependents to the list of the projects
	 * to update.
	 */
	void addToProjectsToUpdateWithDependents(IProject project) {
		this.projectsToUpdate.add(JavaCore.create(project));
		this.addDependentsToProjectsToUpdate(project.getFullPath());
	}
	
	/**
	 * Adds the given child handle to its parent's cache of children. 
	 */
	protected void addToParentInfo(Openable child) {

		Openable parent = (Openable) child.getParent();
		if (parent != null &amp;&amp; parent.isOpen()) {
			try {
				JavaElementInfo info = parent.getElementInfo();
				info.addChild(child);
			} catch (JavaModelException e) {
				// do nothing - we already checked if open
			}
		}
	}



	/**
	 * Check whether the updated file is affecting some of the properties 
of a given project (like
	 * its classpath persisted as a file).
	 * Also force classpath problems to be refresh if not running in 
autobuild mode.
	 * NOTE: It can induce resource changes, and cannot be called during 
POST_CHANGE notification.
	 *
	 */
	public void performPreBuildCheck(
		IResourceDelta delta,
		IJavaElement parent) {
	
		IResource resource = delta.getResource();
		IJavaElement element = JavaCore.create(resource);
		boolean processChildren = false;
	
		switch (resource.getType()) {
	
			case IResource.ROOT :
			case IResource.PROJECT :
				if (delta.getKind() == IResourceDelta.CHANGED) {
					processChildren = true;
				}
				break;
			case IResource.FILE :
				if (parent.getElementType() == 
IJavaElement.JAVA_PROJECT) {
					IFile file = (IFile) resource;
					JavaProject project = (JavaProject) 
parent;
	
					/* check classpath property file change 
*/
					QualifiedName classpathProp;
					if (file.getName().equals(
						
	project.computeSharedPropertyFileName(
								classpathProp = 
project.getClasspathPropertyName()))) {
	
						switch (delta.getKind()) {
							case 
IResourceDelta.REMOVED : // recreate one based on in-memory path
								try {
								
	project.saveClasspath(project.getRawClasspath(), 
project.getOutputLocation());
								} catch 
(JavaModelException e) {
								}
								break;
							case 
IResourceDelta.CHANGED :
								if 
((delta.getFlags() &amp; IResourceDelta.CONTENT) == 0)
								
	break; // only consider content change
							case 
IResourceDelta.ADDED :
								// check if any 
actual difference
								try {
									// 
force to (re)read the property file
									String 
fileClasspathString = project.getSharedProperty(classpathProp);
									if 
(fileClasspathString == null)
									
	break; // did not find the file
								
	IClasspathEntry[] fileEntries = project.readPaths(fileClasspathString);
									if 
(fileEntries == null)
									
	break; // could not read, ignore 
									if 
(project.isClasspathEqualsTo(project.getRawClasspath(), 
project.getOutputLocation(), fileEntries))
									
	break;
	
									// will 
force an update of the classpath/output location based on the file information
									// 
extract out the output location
									IPath 
outputLocation = null;
									if 
(fileEntries != null &amp;&amp; fileEntries.length &gt; 0) {
									
	IClasspathEntry entry = fileEntries[fileEntries.length - 1];
									
	if (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {
										
	outputLocation = entry.getPath();
										
	IClasspathEntry[] copy = new IClasspathEntry[fileEntries.length - 1];
										
	System.arraycopy(fileEntries, 0, copy, 0, copy.length);
										
	fileEntries = copy;
									
	}
									}
									// 
restore output location				
									if 
(outputLocation == null) {
									
	outputLocation = SetClasspathOperation.ReuseOutputLocation;
									}
									try {
									
	project.setRawClasspath(
										
	fileEntries, 
										
	outputLocation, 
										
	null, // monitor
										
	true, // canChangeResource
										
	false, // forceSave
										
	project.getResolvedClasspath(true), // ignoreUnresolvedVariable
										
	true, // needCycleCheck
										
	true); // needValidation
									} catch 
(JavaModelException e) {
									}
								} catch 
(IOException e) {
									break;
								} catch 
(RuntimeException e) {
									break;
								} catch 
(CoreException e) {
									break;
								}
	
						}
					}
				}
				break;
		}
		if (processChildren) {
			IResourceDelta[] children = delta.getAffectedChildren();
			for (int i = 0; i &lt; children.length; i++) {
				performPreBuildCheck(children[i], element);
			}
		}
	}

	/**
	 * Closes the given element, which removes it from the cache of open 
elements.
	 */
	protected static void close(Openable element) {

		try {
			element.close();
		} catch (JavaModelException e) {
			// do nothing
		}
	}


private void cloneCurrentDelta(IJavaProject project, IPackageFragmentRoot root) 
{
	JavaElementDelta delta = (JavaElementDelta)fCurrentDelta.find(root);
	if (delta == null) return;
	JavaElementDelta clone = (JavaElementDelta)delta.clone(project);
	fCurrentDelta.insertDeltaTree(clone.getElement(), clone);
	switch (clone.getKind()) {
		case IJavaElementDelta.ADDED:
			this.addToParentInfo((Openable)clone.getElement());
			break;
		case IJavaElementDelta.REMOVED:
			Openable element = (Openable)clone.getElement();
			if (element.isOpen()) {
				try {
					element.close();
				} catch (JavaModelException e) {
				}
			}
			this.removeFromParentInfo(element);
			break;
	}
}


	/**
	 * Generic processing for elements with changed contents:&lt;ul&gt;
	 * &lt;li&gt;The element is closed such that any subsequent accesses will re-
open
	 * the element reflecting its new structure.
	 * &lt;li&gt;An entry is made in the delta reporting a content change 
(K_CHANGE with F_CONTENT flag set).
	 * &lt;/ul&gt;
	 */
	protected void contentChanged(Openable element, IResourceDelta delta) {

		close(element);
		fCurrentDelta.changed(element, IJavaElementDelta.F_CONTENT);
	}
	/*
	 * Process the given delta and look for projects being added, opened, 
closed or
	 * with a java nature being added or removed.
	 * Note that projects being deleted are checked in deleting(IProject).
	 * In all cases, add the project's dependents to the list of projects 
to update
	 * so that the classpath related markers can be updated.
	 */
	public void checkProjectsBeingAddedOrRemoved(IResourceDelta delta) {
		IResource resource = delta.getResource();
		switch (resource.getType()) {
			case IResource.ROOT :
				// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 15168</a> circular errors not 
reported 
				if (this.manager.javaProjectsCache == null) {
					try {
						this.manager.javaProjectsCache 
= this.manager.getJavaModel().getJavaProjects();
					} catch (JavaModelException e) {
					}
				}
				
				IResourceDelta[] children = 
delta.getAffectedChildren();
				for (int i = 0, length = children.length; i &lt; 
length; i++) {
					this.checkProjectsBeingAddedOrRemoved
(children[i]);
				}
				break;
			case IResource.PROJECT :
				// NB: No need to check project's nature as if 
the project is not a java project:
				//     - if the project is added or changed 
this is a noop for projectsBeingDeleted
				//     - if the project is closed, it has 
already lost its java nature
				int deltaKind = delta.getKind();
				if (deltaKind == IResourceDelta.ADDED) {
					// remember project and its dependents
					IProject project = (IProject)resource;
					this.addToProjectsToUpdateWithDependents
(project);
					
					// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 15168</a> circular 
errors not reported 
					if (this.hasJavaNature(project)) {
						this.addToParentInfo
((JavaProject)JavaCore.create(project));
					}

				} else if (deltaKind == IResourceDelta.CHANGED) 
{
					IProject project = (IProject)resource;
					if ((delta.getFlags() &amp; 
IResourceDelta.OPEN) != 0) {
						// project opened or closed: 
remember  project and its dependents
					
	this.addToProjectsToUpdateWithDependents(project);
						
						// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 15168</a> 
circular errors not reported 
						if (project.isOpen()) {
							if (this.hasJavaNature
(project)) {
							
	this.addToParentInfo((JavaProject)JavaCore.create(project));
							}
						} else {
							JavaProject javaProject 
= (JavaProject)this.manager.getJavaModel().findJavaProject(project);
							if (javaProject != 
null) {
								try {
								
	javaProject.close();
								} catch 
(JavaModelException e) {
								}
							
	this.removeFromParentInfo(javaProject);
							}
						}
					} else if ((delta.getFlags() &amp; 
IResourceDelta.DESCRIPTION) != 0) {
						boolean wasJavaProject = 
this.manager.getJavaModel().findJavaProject(project) != null;
						boolean isJavaProject = 
this.hasJavaNature(project);
						if (wasJavaProject != 
isJavaProject) {
							// java nature added or 
removed: remember  project and its dependents
						
	this.addToProjectsToUpdateWithDependents(project);

							// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 
15168</a> circular errors not reported 
							if (isJavaProject) {
							
	this.addToParentInfo((JavaProject)JavaCore.create(project));
							} else {
								JavaProject 
javaProject = (JavaProject)JavaCore.create(project);
								try {
								
	javaProject.close();
								} catch 
(JavaModelException e) {
								}
							
	this.removeFromParentInfo(javaProject);
							}
						}
					} else {
						// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 15168</a> 
circular errors not reported 
						// in case the project was 
removed then added then changed
						this.addToParentInfo
((JavaProject)JavaCore.create(project));
					}					
				}
				break;
		}
	}

	/**
	 * Creates the openables corresponding to this resource.
	 * Returns null if none was found.
	 */
	protected Openable createElement(IResource resource, int elementType, 
IJavaProject project) {
		if (resource == null) return null;
		
		IPath path = resource.getFullPath();
		IJavaElement element = null;
		switch (elementType) {
			case IJavaElement.JAVA_PROJECT:
				this.popUntilPrefixOf(path);
				if (this.currentElement != null) return 
this.currentElement;
				IProject proj = (IProject)resource;
				boolean isOpened = proj.isOpen();
				if (isOpened &amp;&amp; this.hasJavaNature(proj)) {
					element = project == null ? 
JavaCore.create(proj) : project;
				} else if (!isOpened) {
					if (project == null) {
						project = JavaCore.create(proj);
					}
					if (project.isOpen()) {
						element = project; // java 
project is being closed or removed
					} 
				} // else not a java-project
				break;
			case IJavaElement.PACKAGE_FRAGMENT_ROOT:
				element = project == null ? JavaCore.create
(resource) : project.getPackageFragmentRoot(resource);
				break;
			case IJavaElement.PACKAGE_FRAGMENT:
				// find the element that encloses the resource
				this.popUntilPrefixOf(path);
				
				if (this.currentElement == null) {
					element = 
JavaModelManager.getJavaModelManager().create(resource, project);
				} else {
					// find the root
					IPackageFragmentRoot root = 
this.currentElement.getPackageFragmentRoot();
					if (root == null) {
						element = 
JavaModelManager.getJavaModelManager().create(resource, project);
					} else if (!
JavaModelManager.conflictsWithOutputLocation(path, (JavaProject)
root.getJavaProject())) {
						// create package handle
						IPath pkgPath = 
path.removeFirstSegments(root.getPath().segmentCount());
						String pkg = Util.packageName
(pkgPath);
						if (pkg == null) return null;
						element = 
root.getPackageFragment(pkg);
					}
				}
				break;
			case IJavaElement.COMPILATION_UNIT:
			case IJavaElement.CLASS_FILE:
				// find the element that encloses the resource
				this.popUntilPrefixOf(path);
				
				if (this.currentElement == null) {
					element = element = 
JavaModelManager.getJavaModelManager().create(resource, project);
				} else {
					// find the package
					IPackageFragment pkgFragment = null;
					switch 
(this.currentElement.getElementType()) {
						case 
IJavaElement.PACKAGE_FRAGMENT_ROOT:
							IPackageFragmentRoot 
root = (IPackageFragmentRoot)this.currentElement;
							IPath rootPath = 
root.getPath();
							IPath pkgPath = 
path.removeLastSegments(1);
							String pkgName = 
Util.packageName(pkgPath.removeFirstSegments(rootPath.segmentCount()));
							if (pkgName != null) {
								pkgFragment = 
root.getPackageFragment(pkgName);
							}
							break;
						case 
IJavaElement.PACKAGE_FRAGMENT:
							Openable pkg = 
(Openable)this.currentElement;
							if (pkg.getPath().equals
(path.removeLastSegments(1))) {
								pkgFragment = 
(IPackageFragment)pkg;
							} // else case of 
package x which is a prefix of x.y
							break;
						case 
IJavaElement.COMPILATION_UNIT:
						case IJavaElement.CLASS_FILE:
							pkgFragment = 
(IPackageFragment)this.currentElement.getParent();
							break;
					}
					if (pkgFragment == null) {
						element = 
JavaModelManager.getJavaModelManager().create(resource, project);
					} else {
						if (elementType == 
IJavaElement.COMPILATION_UNIT) {
							// create compilation 
unit handle 
							// fileName validation 
has been done in elementType(IResourceDelta, int, boolean)
							String fileName = 
path.lastSegment();
							element = 
pkgFragment.getCompilationUnit(fileName);
						} else {
							// create class file 
handle
							// fileName validation 
has been done in elementType(IResourceDelta, int, boolean)
							String fileName = 
path.lastSegment();
							element = 
pkgFragment.getClassFile(fileName);
						}
					}
				}
				break;
		}
		if (element == null) {
			return null;
		} else {
			this.currentElement = (Openable)element;
			return this.currentElement;
		}
	}
	/**
	 * Note that the project is about to be deleted.
	 */
	public void deleting(IProject project) {
		
		try {
			JavaProject javaProject = (JavaProject)JavaCore.create
(project);
			javaProject.close();

			// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 15168</a> circular errors not 
reported  
			if (this.manager.javaProjectsCache == null) {
				this.manager.javaProjectsCache = 
this.manager.getJavaModel().getJavaProjects();
			}
			this.removeFromParentInfo(javaProject);

		} catch (JavaModelException e) {
		}
		
		this.addDependentsToProjectsToUpdate(project.getFullPath());
	}

	/**
	 * Processing for an element that has been added:&lt;ul&gt;
	 * &lt;li&gt;If the element is a project, do nothing, and do not process
	 * children, as when a project is created it does not yet have any
	 * natures - specifically a java nature.
	 * &lt;li&gt;If the elemet is not a project, process it as added (see
	 * &lt;code&gt;basicElementAdded&lt;/code&gt;.
	 * &lt;/ul&gt;
	 */
	protected void elementAdded(Openable element, IResourceDelta delta) {
		int elementType = element.getElementType();
		if (elementType == IJavaElement.JAVA_PROJECT) {
			// project add is handled by JavaProject.configure() 
because
			// when a project is created, it does not yet have a 
java nature
			if (hasJavaNature((IProject)delta.getResource())) {
				addToParentInfo(element);
				if ((delta.getFlags() &amp; 
IResourceDelta.MOVED_FROM) != 0) {
					Openable movedFromElement = (Openable)
element.getJavaModel().getJavaProject(delta.getMovedFromPath().lastSegment());
					fCurrentDelta.movedTo(element, 
movedFromElement);
				} else {
					fCurrentDelta.added(element);
				}
				this.projectsToUpdate.add(element);
			}
		} else {
			addToParentInfo(element);
			
			// Force the element to be closed as it might have been 
opened 
			// before the resource modification came in and it 
might have a new child
			// For example, in an IWorkspaceRunnable:
			// 1. create a package fragment p using a java model 
operation
			// 2. open package p
			// 3. add file X.java in folder p
			// When the resource delta comes in, only the addition 
of p is notified, 
			// but the package p is already opened, thus its 
children are not recomputed
			// and it appears empty.
			close(element);
			
			if ((delta.getFlags() &amp; IResourceDelta.MOVED_FROM) != 
0) {
				IPath movedFromPath = delta.getMovedFromPath();
				IResource res = delta.getResource();
				IResource movedFromRes;
				if (res instanceof IFile) {
					movedFromRes = res.getWorkspace
().getRoot().getFile(movedFromPath);
				} else {
					movedFromRes = res.getWorkspace
().getRoot().getFolder(movedFromPath);
				}
				
				// find the element type of the moved from 
element
				IJavaProject projectOfRoot = (IJavaProject)
this.roots.get(movedFromPath);
				boolean isPkgFragmentRoot = 
					projectOfRoot != null 
					&amp;&amp; (projectOfRoot.getProject
().getFullPath().isPrefixOf(movedFromPath));
				int movedFromType = 
					this.elementType(
						movedFromRes, 
						delta.getKind(),
						delta.getFlags(),
						element.getParent
().getElementType(), 
						isPkgFragmentRoot);
				
				// create the moved from element
				Openable movedFromElement = 
					elementType != 
IJavaElement.JAVA_PROJECT &amp;&amp; movedFromType == IJavaElement.JAVA_PROJECT ? 
						null : // outside classpath
						this.createElement
(movedFromRes, movedFromType, null); // pass null for the project in case the 
element is moving to another project
				if (movedFromElement == null) {
					// moved from outside classpath
					fCurrentDelta.added(element);
				} else {
					fCurrentDelta.movedTo(element, 
movedFromElement);
				}
			} else {
				fCurrentDelta.added(element);
			}
			
			switch (elementType) {
				case IJavaElement.PACKAGE_FRAGMENT_ROOT :
					// when a root is added, and is on the 
classpath, the project must be updated
					this.projectsToUpdate.add
(element.getJavaProject());
					break;
				case IJavaElement.PACKAGE_FRAGMENT :
					// get rid of namelookup since it holds 
onto obsolete cached info 
					JavaProject project = (JavaProject) 
element.getJavaProject();
					try {
					
	project.getJavaProjectElementInfo().setNameLookup(null);
					} catch (JavaModelException e) {
					}
					// add subpackages
					PackageFragmentRoot root = 
element.getPackageFragmentRoot();
					String name = element.getElementName();
					IResourceDelta[] children = 
delta.getAffectedChildren();
					for (int i = 0, length = 
children.length; i &lt; length; i++) {
						IResourceDelta child = children
[i];
						IResource resource = 
child.getResource();
						if (resource instanceof 
IFolder) {
							String subpkgName = 
								name.length() 
== 0 ? 
								
	resource.getName() : 
									name 
+ &quot;.&quot; + resource.getName(); //$NON-NLS-1$
							Openable subpkg = 
(Openable)root.getPackageFragment(subpkgName);
							this.updateIndex
(subpkg, child);
							this.elementAdded
(subpkg, child);
						}
					}
					break;
			}
		}
	}





	/**
	 * Generic processing for a removed element:&lt;ul&gt;
	 * &lt;li&gt;Close the element, removing its structure from the cache
	 * &lt;li&gt;Remove the element from its parent's cache of children
	 * &lt;li&gt;Add a REMOVED entry in the delta
	 * &lt;/ul&gt;
	 */
	protected void elementRemoved(Openable element, IResourceDelta delta) {
		
		if (element.isOpen()) {
			close(element);
		}
		removeFromParentInfo(element);
		int elementType = element.getElementType();
		if ((delta.getFlags() &amp; IResourceDelta.MOVED_TO) != 0) {
			IPath movedToPath = delta.getMovedToPath();
			IResource res = delta.getResource();
			IResource movedToRes;
			switch (res.getType()) {
				case IResource.PROJECT:
					movedToRes = res.getWorkspace().getRoot
().getProject(movedToPath.lastSegment());
					break;
				case IResource.FOLDER:
					movedToRes = res.getWorkspace().getRoot
().getFolder(movedToPath);
					break;
				case IResource.FILE:
					movedToRes = res.getWorkspace().getRoot
().getFile(movedToPath);
					break;
				default:
					return;
			}

			// find the element type of the moved from element
			IJavaProject projectOfRoot = (IJavaProject)
this.roots.get(movedToPath);
			boolean isPkgFragmentRoot = 
				projectOfRoot != null 
				&amp;&amp; (projectOfRoot.getProject().getFullPath
().isPrefixOf(movedToPath));
			int movedToType = 
				this.elementType(
					movedToRes, 
					delta.getKind(),
					delta.getFlags(),
					element.getParent().getElementType(), 
					isPkgFragmentRoot);
			
			// create the moved To element
			Openable movedToElement = 
				elementType != IJavaElement.JAVA_PROJECT &amp;&amp; 
movedToType == IJavaElement.JAVA_PROJECT ? 
					null : // outside classpath
					this.createElement(movedToRes, 
movedToType, null); // pass null for the project in case the element is moving 
to another project
			if (movedToElement == null) {
				// moved outside classpath
				fCurrentDelta.removed(element);
			} else {
				fCurrentDelta.movedFrom(element, 
movedToElement);
			}
		} else {
			fCurrentDelta.removed(element);
		}

		switch (elementType) {
			case IJavaElement.JAVA_MODEL :
				this.indexManager.reset();
				break;
			case IJavaElement.JAVA_PROJECT :
				JavaModelManager.getJavaModelManager
().removePerProjectInfo(
					(JavaProject) element);
				break;
			case IJavaElement.PACKAGE_FRAGMENT_ROOT :
				this.projectsToUpdate.add(element.getJavaProject
());
				break;
			case IJavaElement.PACKAGE_FRAGMENT :
				//1G1TW2T - get rid of namelookup since it 
holds onto obsolete cached info 
				JavaProject project = (JavaProject) 
element.getJavaProject();
				try {
					project.getJavaProjectElementInfo
().setNameLookup(null);
				} catch (JavaModelException e) {
				}
				// remove subpackages
				PackageFragmentRoot root = 
element.getPackageFragmentRoot();
				String name = element.getElementName();
				IResourceDelta[] children = 
delta.getAffectedChildren();
				for (int i = 0, length = children.length; i &lt; 
length; i++) {
					IResourceDelta child = children[i];
					IResource resource = child.getResource
();
					if (resource instanceof IFolder) {
						String subpkgName = 
							name.length() == 0 ? 
								resource.getName
() : 
								name + &quot;.&quot; + 
resource.getName(); //$NON-NLS-1$
						Openable subpkg = (Openable)
root.getPackageFragment(subpkgName);
						this.updateIndex(subpkg, child);
						this.elementRemoved(subpkg, 
child);
					}
				}
				break;
		}
	}

	/**
	 * Filters the generated &lt;code&gt;JavaElementDelta&lt;/code&gt;s to remove those
	 * which should not be fired (because they don't represent a real change
	 * in the Java Model).
	 */
	protected IJavaElementDelta[] filterRealDeltas(IJavaElementDelta[] 
deltas) {

		int length = deltas.length;
		IJavaElementDelta[] realDeltas = null;
		int index = 0;
		for (int i = 0; i &lt; length; i++) {
			JavaElementDelta delta = (JavaElementDelta)deltas[i];
			if (delta == null) {
				continue;
			}
			if (delta.getAffectedChildren().length &gt; 0
				|| delta.getKind() == IJavaElementDelta.ADDED
				|| delta.getKind() == IJavaElementDelta.REMOVED
				|| (delta.getFlags() &amp; 
IJavaElementDelta.F_CLOSED) != 0
				|| (delta.getFlags() &amp; 
IJavaElementDelta.F_OPENED) != 0
				|| delta.resourceDeltasCounter &gt; 0) {

				if (realDeltas == null) {
					realDeltas = new IJavaElementDelta
[length];
				}
				realDeltas[index++] = delta;
			}
		}
		if (index &gt; 0) {
			IJavaElementDelta[] result = new IJavaElementDelta
[index];
			System.arraycopy(realDeltas, 0, result, 0, index);
			return result;
		} else {
			return NO_DELTA;
		}
	}

/**
 * Returns true if the given resource is contained in an open project
 * with a java nature, otherwise false.
 */
protected boolean hasJavaNature(IResource resource) {
	// ensure the project has a java nature (if open)
	IProject project = resource.getProject();
	if (project.isOpen()) {
		try {
			return project.hasNature(JavaCore.NATURE_ID);
		} catch (CoreException e) {
			// do nothing
		}
	}
	return false;
}


private JavaModelException newInvalidElementType() {
	return new JavaModelException(new JavaModelStatus
(IJavaModelStatusConstants.INVALID_ELEMENT_TYPES));
}
	/**
	 * Generic processing for elements with changed contents:&lt;ul&gt;
	 * &lt;li&gt;The element is closed such that any subsequent accesses will re-
open
	 * the element reflecting its new structure.
	 * &lt;li&gt;An entry is made in the delta reporting a content change 
(K_CHANGE with F_CONTENT flag set).
	 * &lt;/ul&gt;
	 */
	protected void nonJavaResourcesChanged(Openable element, IResourceDelta 
delta)
		throws JavaModelException {

		// reset non-java resources if element was open
		if (element.isOpen()) {
			JavaElementInfo info = element.getElementInfo();
			switch (element.getElementType()) {
				case IJavaElement.JAVA_PROJECT :
					((JavaProjectElementInfo) 
info).setNonJavaResources(null);
	
					// if a package fragment root is the 
project, clear it too
					PackageFragmentRoot projectRoot =
						(PackageFragmentRoot) 
((JavaProject) element).getPackageFragmentRoot(
							new Path
(IPackageFragment.DEFAULT_PACKAGE_NAME));
					if (projectRoot.isOpen()) {
						((PackageFragmentRootInfo) 
projectRoot.getElementInfo()).setNonJavaResources(
							null);
					}
					break;
				case IJavaElement.PACKAGE_FRAGMENT :
					 ((PackageFragmentInfo) 
info).setNonJavaResources(null);
					break;
				case IJavaElement.PACKAGE_FRAGMENT_ROOT :
					 ((PackageFragmentRootInfo) 
info).setNonJavaResources(null);
			}
		}

		JavaElementDelta elementDelta = fCurrentDelta.find(element);
		if (elementDelta == null) {
			fCurrentDelta.changed(element, 
IJavaElementDelta.F_CONTENT);
			elementDelta = fCurrentDelta.find(element);
		}
		elementDelta.addResourceDelta(delta);
	}
	private void popUntilPrefixOf(IPath path) {
		while (this.currentElement != null) {
			IPath currentElementPath = null;
			if (this.currentElement instanceof 
IPackageFragmentRoot) {
				currentElementPath = ((IPackageFragmentRoot)
this.currentElement).getPath();
			} else {
				IResource currentElementResource = null;
				try {
					currentElementResource = 
this.currentElement.getUnderlyingResource();
				} catch (JavaModelException e) {
				}
				if (currentElementResource != null) {
					currentElementPath = 
currentElementResource.getFullPath();
				}
			}
			if (currentElementPath != null) {
				if (this.currentElement instanceof 
IPackageFragment 
					&amp;&amp; this.currentElement.getElementName
().length() == 0
					&amp;&amp; currentElementPath.segmentCount() != 
path.segmentCount()-1) {
						// default package and path is 
not a direct child
						this.currentElement = (Openable)
this.currentElement.getParent();
				}
				if (currentElementPath.isPrefixOf(path)) {
					return;
				}
			}
			this.currentElement = (Openable)
this.currentElement.getParent();
		}
	}

	/**
	 * Generate deltas for affected package fragment roots
	 */
	public IJavaElementDelta processExternalJarChanges() {
		
		// did any external JAR change ?
		if (this.externalJarPathsToUpdate.isEmpty()) return null;
		try {
			JavaModel model = manager.getJavaModel();
			fCurrentDelta = new JavaElementDelta(model);
			IJavaProject[] projects =model.getOldJavaProjectsList();
			for (int i = 0, length = projects.length; i &lt; length; 
i++) {
				IJavaProject project = projects[i];
				IPackageFragmentRoot[] roots = 
project.getPackageFragmentRoots();
				for (int j = 0; j &lt; roots.length; j++){
					if 
(this.externalJarPathsToUpdate.contains(roots[j].getPath())){
						if (VERBOSE){
							System.out.println
(&quot;External JAR changed, affecting root: &quot;+roots[j].getElementName());
						}
						contentChanged((Openable)roots
[j], null);
					}
				}
			}
			return fCurrentDelta;
		} catch (JavaModelException e) { // nothing can be done
		} finally {
			this.externalJarPathsToUpdate.clear();
		}
		return null;
	}
	
	/**
	 * Converts a &lt;code&gt;IResourceDelta&lt;/code&gt; rooted in a 
&lt;code&gt;Workspace&lt;/code&gt; into
	 * the corresponding set of &lt;code&gt;IJavaElementDelta&lt;/code&gt;, rooted in 
the
	 * relevant &lt;code&gt;JavaModel&lt;/code&gt;s.
	 */
	public IJavaElementDelta[] processResourceDelta(IResourceDelta changes, 
int eventType) {

		try {
			this.currentEventType = eventType;
			IJavaModel model = JavaModelManager.getJavaModelManager
().getJavaModel();
			if (!model.isOpen()) {
				// force opening of java model so that java 
element delta are reported
				try {
					model.open(null);
				} catch (JavaModelException e) {
					if (VERBOSE) {
						e.printStackTrace();
					}
					return NO_DELTA;
				}
			}
			this.initializeRoots(model);
			this.currentElement = null;
			
			// get the workspace delta, and start processing there.
			IResourceDelta[] deltas = changes.getAffectedChildren();
			IJavaElementDelta[] translatedDeltas = new 
JavaElementDelta[deltas.length];
			for (int i = 0; i &lt; deltas.length; i++) {
				IResourceDelta delta = deltas[i];
				IResource res = delta.getResource();
				fCurrentDelta = new JavaElementDelta(model);
				
				// find out whether the delta is a package 
fragment root
				IJavaProject projectOfRoot = (IJavaProject)
this.roots.get(res.getFullPath());
				boolean isPkgFragmentRoot = projectOfRoot != 
null;
				int elementType = 
					this.elementType(
						res, 
						delta.getKind(),
						delta.getFlags(),
						IJavaElement.JAVA_MODEL, 
						isPkgFragmentRoot);
				
				this.traverseDelta(delta, elementType, 
projectOfRoot, null, IGNORE); // traverse delta
				translatedDeltas[i] = fCurrentDelta;
			}
			
			// update package fragment roots of projects that were 
affected
			Iterator iterator = this.projectsToUpdate.iterator();
			while (iterator.hasNext()) {
				JavaProject project = (JavaProject)iterator.next
();
				project.updatePackageFragmentRoots();
			}
	
			return filterRealDeltas(translatedDeltas);
		} finally {
			this.projectsToUpdate = new HashSet();
		}
	}
	
/*
 * Update the current delta (ie. add/remove/change the given element) and 
update the correponding index.
 * Returns whether the children of the given delta must be processed.
 * &#64;throws a JavaModelException if the delta doesn't correspond to a java 
element of the given type.
 */
private boolean updateCurrentDeltaAndIndex(IResourceDelta delta, int 
elementType, IJavaProject project) throws JavaModelException {
	Openable element;
	switch (delta.getKind()) {
		case IResourceDelta.ADDED :
			element = this.createElement(delta.getResource(), 
elementType, project);
			if (element == null) throw newInvalidElementType();
			this.updateIndex(element, delta);
			this.elementAdded(element, delta);
			return false;
		case IResourceDelta.REMOVED :
			element = this.createElement(delta.getResource(), 
elementType, project);
			if (element == null) throw newInvalidElementType();
			this.updateIndex(element, delta);
			this.elementRemoved(element, delta);
			return false;
		case IResourceDelta.CHANGED :
			int flags = delta.getFlags();
			if ((flags &amp; IResourceDelta.CONTENT) != 0) {
				// content has changed
				element = this.createElement(delta.getResource
(), elementType, project);
				if (element == null) throw newInvalidElementType
();
				this.updateIndex(element, delta);
				this.contentChanged(element, delta);
			} else if (elementType == IJavaElement.JAVA_PROJECT) {
				if ((flags &amp; IResourceDelta.OPEN) != 0) {
					// project has been opened or closed
					IProject res = (IProject)
delta.getResource();
					element = this.createElement(res, 
elementType, project);
					if (element == null) throw 
newInvalidElementType();
					if (res.isOpen()) {
						if (this.hasJavaNature(res)) {
							this.elementAdded
(element, delta);
						
	this.indexManager.indexAll(res);
						}
					} else {
						JavaModel javaModel = 
JavaModelManager.getJavaModelManager().getJavaModel();
						boolean wasJavaProject = 
javaModel.findJavaProject(res) != null;
						if (wasJavaProject) {
							this.elementRemoved
(element, delta);
						
	this.indexManager.discardJobs(element.getElementName());
						
	this.indexManager.removeIndex(res.getFullPath());
							
						}
					}
					return false; // when a project is 
open/closed don't process children
				}
				if ((flags &amp; IResourceDelta.DESCRIPTION) != 0) {
					IProject res = (IProject)
delta.getResource();
					JavaModel javaModel = 
JavaModelManager.getJavaModelManager().getJavaModel();
					boolean wasJavaProject = 
javaModel.findJavaProject(res) != null;
					boolean isJavaProject = 
this.hasJavaNature(res);
					if (wasJavaProject != isJavaProject) {
						// project's nature has been 
added or removed
						element = this.createElement
(res, elementType, project);
						if (element == null) throw 
newInvalidElementType();
						if (isJavaProject) {
							this.elementAdded
(element, delta);
						
	this.indexManager.indexAll(res);
						} else {
							this.elementRemoved
(element, delta);
						
	this.indexManager.discardJobs(element.getElementName());
						
	this.indexManager.removeIndex(res.getFullPath());
						}
						return false; // when a 
project's nature is added/removed don't process children
					}
				}
			}
			return true;
	}
	return true;
}

	/**
	 * Removes the given element from its parents cache of children. If the
	 * element does not have a parent, or the parent is not currently open,
	 * this has no effect. 
	 */
	protected void removeFromParentInfo(Openable child) {

		Openable parent = (Openable) child.getParent();
		if (parent != null &amp;&amp; parent.isOpen()) {
			try {
				JavaElementInfo info = parent.getElementInfo();
				info.removeChild(child);
			} catch (JavaModelException e) {
				// do nothing - we already checked if open
			}
		}
	}
	/**
	 * Notification that some resource changes have happened
	 * on the platform, and that the Java Model should update any required
	 * internal structures such that its elements remain consistent.
	 * Translates &lt;code&gt;IResourceDeltas&lt;/code&gt; into 
&lt;code&gt;IJavaElementDeltas&lt;/code&gt;.
	 *
	 * &#64;see IResourceDelta
	 * &#64;see IResource 
	 */
	public void resourceChanged(IResourceChangeEvent event) {

		JavaModelManager.IsResourceTreeLocked = false;
		
		if (event.getSource() instanceof IWorkspace) {
			IResource resource = event.getResource();
			IResourceDelta delta = event.getDelta();
			
			switch(event.getType()){
				case IResourceChangeEvent.PRE_DELETE :
					try {
						if(resource.getType() == 
IResource.PROJECT 
							&amp;&amp; ((IProject) 
resource).hasNature(JavaCore.NATURE_ID)) {
								
							this.deleting((IProject)
resource);
						}
					} catch(CoreException e){
					}
					return;
					
				case IResourceChangeEvent.PRE_AUTO_BUILD :
					if(delta != null) {
					
	this.checkProjectsBeingAddedOrRemoved(delta);
						
						// update the classpath related 
markers
						this.updateClasspathMarkers();

						// the following will close 
project if affected by the property file change
						this.performPreBuildCheck
(delta, null); 
					}
					// only fire already computed deltas 
(resource ones will be processed in post change only)
					this.manager.fire(null, 
ElementChangedEvent.PRE_AUTO_BUILD);
					break;
					
				case IResourceChangeEvent.POST_CHANGE :
					try {
					
	JavaModelManager.IsResourceTreeLocked = true;
						if (delta != null) {
							IJavaElementDelta[] 
translatedDeltas = this.processResourceDelta(delta, 
ElementChangedEvent.POST_CHANGE);
							if 
(translatedDeltas.length &gt; 0) {
								for (int i= 0; 
i &lt; translatedDeltas.length; i++) {
								
	this.manager.registerJavaModelDelta(translatedDeltas[i]);
								}
							}
							/*
							IJavaElementDelta 
externalDelta = this.processExternalJarChanges();
							if (externalDelta != 
null){
							
	this.manager.registerJavaModelDelta(externalDelta);
							}
							*/
							this.manager.fire(null, 
ElementChangedEvent.POST_CHANGE);
						}		
					} finally {
						// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 15168</a> 
circular errors not reported 
						this.manager.javaProjectsCache 
= null;
					
	JavaModelManager.IsResourceTreeLocked = false;
					}
			}
		}
	}

	/**
	 * Converts an &lt;code&gt;IResourceDelta&lt;/code&gt; and its children into
	 * the corresponding &lt;code&gt;IJavaElementDelta&lt;/code&gt;s.
	 * Return whether the delta corresponds to a resource on the classpath.
	 * If it is not a resource on the classpath, it will be added as a non-
java
	 * resource by the sender of this method.
	 */
	protected boolean traverseDelta(
		IResourceDelta delta, 
		int elementType, 
		IJavaProject currentProject,
		IPath currentOutput,
		int outputTraverseMode) {
			
		IResource res = delta.getResource();
		
		// process current delta
		boolean processChildren = true;
		if (currentProject != null || res instanceof IProject) {
			if (this.currentElement == null || !
this.currentElement.getJavaProject().equals(currentProject)) {
				// force the currentProject to be used
				this.currentElement = (Openable)currentProject;
			}
			try {
				processChildren = 
this.updateCurrentDeltaAndIndex(delta, elementType, currentProject);
			} catch (JavaModelException e) {
				// non java resource or invalid project
				return false;
			}
		} else {
			// not yet inside a package fragment root
			processChildren = true;
		}
		
		// get the project's output location
		if (currentOutput == null) {
			try {
				IJavaProject proj =
					currentProject == null ?
						(IJavaProject)this.createElement
(res.getProject(), IJavaElement.JAVA_PROJECT, null) :
						currentProject;
				if (proj != null) {
					currentOutput = proj.getOutputLocation
();
					if (proj.getProject().getFullPath
().equals(currentOutput)){ // case of proj==bin==src
						outputTraverseMode = SOURCE;
					} else {
						// check case of src==bin
						IClasspathEntry[] classpath = 
proj.getResolvedClasspath(true);
						for (int i = 0, length = 
classpath.length; i &lt; length; i++) {
							IClasspathEntry entry = 
classpath[i];
							if (entry.getPath
().equals(currentOutput)) {
							
	outputTraverseMode = (entry.getEntryKind() == 
IClasspathEntry.CPE_SOURCE) ? SOURCE : BINARY;
								break;
							}
						}
					}
				}
			} catch (JavaModelException e) {
			}
		}

		// process children if needed
		if (processChildren) {
			IResourceDelta[] children = delta.getAffectedChildren();
			boolean oneChildOnClasspath = false;
			int length = children.length;
			IResourceDelta[] orphanChildren = new IResourceDelta
[length];
			Openable parent = null;
			boolean isValidParent = true;
			for (int i = 0; i &lt; length; i++) {
				IResourceDelta child = children[i];
				IResource childRes = child.getResource();
				IPath childPath = childRes.getFullPath();

				// find out whether the child is a package 
fragment root of the current project
				IJavaProject projectOfRoot = (IJavaProject)
this.roots.get(childPath);
				boolean isPkgFragmentRoot = 
					projectOfRoot != null 
					&amp;&amp; (projectOfRoot.getProject
().getFullPath().isPrefixOf(childPath));
				int childType = 
					this.elementType(
						childRes, 
						child.getKind(),
						child.getFlags(),
						elementType, 
						isPkgFragmentRoot);
				
				// filter out changes in output location
				if (currentOutput != null &amp;&amp; 
currentOutput.isPrefixOf(childPath)) {
					if (outputTraverseMode != IGNORE) {
						// case of bin=src
						if (outputTraverseMode == 
SOURCE &amp;&amp; childType == IJavaElement.CLASS_FILE) {
							continue;
						}
						// case of .class file under 
project and no source folder
						// proj=bin
						if (childType == 
IJavaElement.JAVA_PROJECT 
							&amp;&amp; childRes instanceof 
IFile 
							&amp;&amp; 
Util.isValidClassFileName(childRes.getName())) {
							continue;
						}
					} else {
						continue;
					}
				}
				
				// traverse delta for child in the same project
				if (childType == -1
					|| !this.traverseDelta(child, 
childType, (currentProject == null &amp;&amp; isPkgFragmentRoot) ? projectOfRoot : 
currentProject, currentOutput, outputTraverseMode)) {
					try {
						if (currentProject != null) {
							if (!isValidParent) 
continue; 
							if (parent == null) {
								if 
(this.currentElement == null || !this.currentElement.getJavaProject().equals
(currentProject)) {
									// 
force the currentProject to be used
								
	this.currentElement = (Openable)currentProject;
								}
								if (elementType 
== IJavaElement.JAVA_PROJECT
									|| 
(elementType == IJavaElement.PACKAGE_FRAGMENT_ROOT &amp;&amp; res instanceof IProject)) 
{ 
									// NB: 
attach non-java resource to project (not to its package fragment root)
									parent 
= (Openable)currentProject;
								} else {
									parent 
= this.createElement(res, elementType, currentProject);
								}
								if (parent == 
null) {
								
	isValidParent = false;
								
	continue;
								}
							}
							// add child as non 
java resource
							nonJavaResourcesChanged
(parent, child);
						} else {
							orphanChildren[i] = 
child;
						}
					} catch (JavaModelException e) {
					}
				} else {
					oneChildOnClasspath = true;
				}
				
				// if child is a package fragment root of 
another project, traverse delta too
				if (projectOfRoot != null &amp;&amp; !
isPkgFragmentRoot) {
					this.traverseDelta(child, 
IJavaElement.PACKAGE_FRAGMENT_ROOT, projectOfRoot, null, IGNORE); // binary 
output of projectOfRoot cannot be this root
					// NB: No need to check the return 
value as the child can only be on the classpath
				}
				
				// if the child is a package fragment root of 
one or several other projects
				HashSet set;
				if ((set = (HashSet)this.otherRoots.get
(childPath)) != null) {
					IPackageFragmentRoot currentRoot = 
						(currentProject == null ? 
							projectOfRoot : 
						
	currentProject).getPackageFragmentRoot(childRes);
					Iterator iterator = set.iterator();
					while (iterator.hasNext()) {
						IJavaProject project = 
(IJavaProject) iterator.next();
						this.cloneCurrentDelta(project, 
currentRoot);
					}
				}
			}
			if (oneChildOnClasspath || res instanceof IProject) {
				// add orphan children (case of non java 
resources under project)
				JavaProject adoptiveProject = (JavaProject)
JavaCore.getJavaCore().create(res.getProject());
				if (adoptiveProject != null) {
					for (int i = 0; i &lt; length; i++) {
						if (orphanChildren[i] != null) {
							try {
							
	nonJavaResourcesChanged(adoptiveProject, orphanChildren[i]);
							} catch 
(JavaModelException e) {
							}
						}
					}
				}
			} // else resource delta will be added by parent
			return isValidParent &amp;&amp; (currentProject != null || 
oneChildOnClasspath);
		} else {
			// if not on classpath or if the element type is -1, 
			// it's a non-java resource
			return currentProject != null &amp;&amp; elementType != -1;
		}
	}
	/**
	 * Update the classpath markers and cycle markers for the projects to 
update.
	 */
	void updateClasspathMarkers() {
		try {
			if (!ResourcesPlugin.getWorkspace().isAutoBuilding()) {
				Iterator iterator = 
this.projectsToUpdate.iterator();
				while (iterator.hasNext()) {
					try {
						JavaProject project = 
(JavaProject)iterator.next();
						
						 // force classpath marker 
refresh
						project.getResolvedClasspath(
							true, // 
ignoreUnresolvedEntry
							true); // 
generateMarkerOnError
						
					} catch (JavaModelException e) {
					}
				}
			}
			if (!this.projectsToUpdate.isEmpty()){
				try {
					// update all cycle markers
					JavaProject.updateAllCycleMarkers();
				} catch (JavaModelException e) {
				}
			}				
		} finally {
			this.projectsToUpdate = new HashSet();
		}
	
	}

	/*
	 * Returns the type of the java element the given delta matches to.
	 * Returns -1 if unknown (e.g. a non-java resource.)
	 */
	private int elementType(IResource res, int kind, int flags, int 
parentType, boolean isPkgFragmentRoot) {
		switch (parentType) {
			case IJavaElement.JAVA_MODEL:
				if (kind != IResourceDelta.CHANGED
					|| (flags &amp; IResourceDelta.OPEN) != 0
					|| (flags &amp; 
IResourceDelta.DESCRIPTION) != 0) {
					// project is added, removed, opened or 
closed, or its nature is changed
					return IJavaElement.JAVA_PROJECT;
				} // else see below
			case IJavaElement.JAVA_PROJECT:
				if (isPkgFragmentRoot) {
					return 
IJavaElement.PACKAGE_FRAGMENT_ROOT;
				} else {
					return IJavaElement.JAVA_PROJECT; // 
not yet in a package fragment root
				}
			case IJavaElement.PACKAGE_FRAGMENT_ROOT:
			case IJavaElement.PACKAGE_FRAGMENT:
				if (res instanceof IFolder) {
					if (Util.isValidFolderNameForPackage
(res.getName())) {
						return 
IJavaElement.PACKAGE_FRAGMENT;
					} else {
						return -1;
					}
				} else {
					String fileName = res.getName();
					if (Util.isValidCompilationUnitName
(fileName)) {
						return 
IJavaElement.COMPILATION_UNIT;
					} else if (Util.isValidClassFileName
(fileName)) {
						return IJavaElement.CLASS_FILE;
					} else if (this.roots.get
(res.getFullPath()) != null) {
						// case of proj=src=bin and 
resource is a jar file on the classpath
						return 
IJavaElement.PACKAGE_FRAGMENT_ROOT;
					} else {
						return -1;
					}
				}
			default:
				return -1;
		}
	}
	
private void initializeRoots(IJavaModel model) {
	this.roots = new HashMap();
	this.otherRoots = new HashMap();
	IJavaProject[] projects;
	try {
		projects = ((JavaModel)model).getOldJavaProjectsList();
	} catch (JavaModelException e) {
		// nothing can be done
		return;
	}
	for (int i = 0, length = projects.length; i &lt; length; i++) {
		IJavaProject project = projects[i];
		IClasspathEntry[] classpath;
		try {
			classpath = project.getResolvedClasspath(true);
		} catch (JavaModelException e) {
			// continue with next project
			continue;
		}
		for (int j= 0, classpathLength = classpath.length; j &lt; 
classpathLength; j++) {
			IClasspathEntry entry = classpath[j];
			if (entry.getEntryKind() == 
IClasspathEntry.CPE_PROJECT) continue;
			IPath path = entry.getPath();
			if (this.roots.get(path) == null) {
				this.roots.put(path, project);
			} else {
				HashSet set = (HashSet)this.otherRoots.get
(path);
				if (set == null) {
					set = new HashSet();
					this.otherRoots.put(path, set);
				}
				set.add(project);
			}
		}
	}
}

private boolean isOnClasspath(IPath path) {
	return this.roots.get(path) != null;
}

protected void updateIndex(Openable element, IResourceDelta delta) {

	if (indexManager == null)
		return;

	switch (element.getElementType()) {
		case IJavaElement.JAVA_PROJECT :
			switch (delta.getKind()) {
				case IResourceDelta.ADDED :
					this.indexManager.indexAll
(element.getJavaProject().getProject());
					break;
				case IResourceDelta.REMOVED :
					this.indexManager.discardJobs
(element.getElementName());
					this.indexManager.removeIndex
(element.getJavaProject().getProject().getFullPath());
					break;
				// NB: Update of index if project is opened, 
closed, or its java nature is added or removed
				//     is done in updateCurrentDeltaAndIndex
			}
			break;
		case IJavaElement.PACKAGE_FRAGMENT_ROOT :
			if (element instanceof JarPackageFragmentRoot) {
				JarPackageFragmentRoot root = 
(JarPackageFragmentRoot)element;
				// index jar file only once (if the root is in 
its declaring project)
				IPath jarPath = root.getPath();
				switch (delta.getKind()) {
					case IResourceDelta.ADDED:
						// index the new jar
						indexManager.indexLibrary
(jarPath, root.getJavaProject().getProject());
						break;
					case IResourceDelta.CHANGED:
						// first remove the index so 
that it is forced to be re-indexed
						indexManager.removeIndex
(jarPath);
						// then index the jar
						indexManager.indexLibrary
(jarPath, root.getJavaProject().getProject());
						break;
					case IResourceDelta.REMOVED:
						// the jar was physically 
removed: remove the index
						indexManager.removeIndex
(jarPath);
						break;
				}
				break;
			} else {
				int kind = delta.getKind();
				if (kind == IResourceDelta.ADDED || kind == 
IResourceDelta.REMOVED) {
					IPackageFragmentRoot root = 
(IPackageFragmentRoot)element;
					this.updateRootIndex(root, 
root.getPackageFragment(&quot;&quot;), delta); //$NON-NLS-1$
					break;
				}
			}
			// don't break as packages of the package fragment root 
can be indexed below
		case IJavaElement.PACKAGE_FRAGMENT :
			switch (delta.getKind()) {
				case IResourceDelta.ADDED:
				case IResourceDelta.REMOVED:
					IPackageFragment pkg = null;
					if (element instanceof 
IPackageFragmentRoot) {
						IPackageFragmentRoot root = 
(IPackageFragmentRoot)element;
						pkg = root.getPackageFragment
(&quot;&quot;); //$NON-NLS-1$
					} else {
						pkg = (IPackageFragment)element;
					}
					IResourceDelta[] children = 
delta.getAffectedChildren();
					for (int i = 0, length = 
children.length; i &lt; length; i++) {
						IResourceDelta child = children
[i];
						IResource resource = 
child.getResource();
						if (resource instanceof IFile) {
							String extension = 
resource.getFileExtension();
							if 
(&quot;java&quot;.equalsIgnoreCase(extension)) { //$NON-NLS-1$
								Openable cu = 
(Openable)pkg.getCompilationUnit(resource.getName());
								this.updateIndex
(cu, child);
							} else if 
(&quot;class&quot;.equalsIgnoreCase(extension)) { //$NON-NLS-1$
								Openable 
classFile = (Openable)pkg.getClassFile(resource.getName());
								this.updateIndex
(classFile, child);
							}
						}
					}
					break;
			}
			break;
		case IJavaElement.CLASS_FILE :
			IFile file = (IFile) delta.getResource();
			IJavaProject project = element.getJavaProject();
			IPath binaryFolderPath = element.getPackageFragmentRoot
().getPath();
			// if the class file is part of the binary output, it 
has been created by
			// the java builder -&gt; ignore
			try {
				if (binaryFolderPath.equals
(project.getOutputLocation())) {
					break;
				}
			} catch (JavaModelException e) {
			}
			switch (delta.getKind()) {
				case IResourceDelta.CHANGED :
					// no need to index if the content has 
not changed
					if ((delta.getFlags() &amp; 
IResourceDelta.CONTENT) == 0)
						break;
				case IResourceDelta.ADDED :
					indexManager.addBinary(file, 
binaryFolderPath);
					break;
				case IResourceDelta.REMOVED :
					indexManager.remove(file.getFullPath
().toString(), binaryFolderPath);
					break;
			}
			break;
		case IJavaElement.COMPILATION_UNIT :
			file = (IFile) delta.getResource();
			switch (delta.getKind()) {
				case IResourceDelta.CHANGED :
					// no need to index if the content has 
not changed
					if ((delta.getFlags() &amp; 
IResourceDelta.CONTENT) == 0)
						break;
				case IResourceDelta.ADDED :
					indexManager.addSource(file, 
file.getProject().getProject().getFullPath());
					break;
				case IResourceDelta.REMOVED :
					indexManager.remove(file.getFullPath
().toString(), file.getProject().getProject().getFullPath());
					break;
			}
	}
}
/**
 * Upadtes the index of the given root (assuming it's an addition or a removal).
 * This is done recusively, pkg being the current package.
 */
private void updateRootIndex(IPackageFragmentRoot root, IPackageFragment pkg, 
IResourceDelta delta) {
	this.updateIndex((Openable)pkg, delta);
	IResourceDelta[] children = delta.getAffectedChildren();
	String name = pkg.getElementName();
	for (int i = 0, length = children.length; i &lt; length; i++) {
		IResourceDelta child = children[i];
		IResource resource = child.getResource();
		if (resource instanceof IFolder) {
			String subpkgName = 
				name.length() == 0 ? 
					resource.getName() : 
					name + &quot;.&quot; + resource.getName(); //$NON-
NLS-1$
			IPackageFragment subpkg = root.getPackageFragment
(subpkgName);
			this.updateRootIndex(root, subpkg, child);
		}
	}
}

}]

Source after: 
[/******************************************************************************
*
 * Copyright (c) 2000, 2001, 2002 International Business Machines Corp. and 
others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v0.5 
 * which accompanies this distribution, and is available at
 * <a href="http://www.eclipse.org/legal/cpl-v05.html">http://www.eclipse.org/legal/cpl-v05.html</a>
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 ******************************************************************************/
package org.eclipse.jdt.internal.core;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceChangeEvent;
import org.eclipse.core.resources.IResourceChangeListener;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.QualifiedName;
import org.eclipse.jdt.core.ElementChangedEvent;
import org.eclipse.jdt.core.IClasspathEntry;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IJavaElementDelta;
import org.eclipse.jdt.core.IJavaModel;
import org.eclipse.jdt.core.IJavaModelStatusConstants;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IPackageFragment;
import org.eclipse.jdt.core.IPackageFragmentRoot;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.internal.core.search.indexing.IndexManager;

/**
 * This class is used by &lt;code&gt;JavaModelManager&lt;/code&gt; to convert
 * &lt;code&gt;IResourceDelta&lt;/code&gt;s into &lt;code&gt;IJavaElementDelta&lt;/code&gt;s.
 * It also does some processing on the &lt;code&gt;JavaElement&lt;/code&gt;s involved
 * (e.g. closing them or updating classpaths).
 */
public class DeltaProcessor implements IResourceChangeListener {
	
	final static int IGNORE = 0;
	final static int SOURCE = 1;
	final static int BINARY = 2;
	
	final static String EXTERNAL_JAR_ADDED = &quot;external jar added&quot;; //$NON-
NLS-1$
	final static String EXTERNAL_JAR_REMOVED = &quot;external jar removed&quot;; //
$NON-NLS-1$
	final static String EXTERNAL_JAR_CHANGED = &quot;external jar changed&quot;; //
$NON-NLS-1$
	final static String EXTERNAL_JAR_UNCHANGED = &quot;external jar 
unchanged&quot;; //$NON-NLS-1$
	final static String INTERNAL_JAR_IGNORE = &quot;internal jar ignore&quot;; //$NON-
NLS-1$
	
	/**
	 * The &lt;code&gt;JavaElementDelta&lt;/code&gt; corresponding to the 
&lt;code&gt;IResourceDelta&lt;/code&gt; being translated.
	 */
	protected JavaElementDelta fCurrentDelta;
	
	protected IndexManager indexManager = new IndexManager();
		
	/* A table from IPath (from a classpath entry) to IJavaProject */
	Map roots;
	
	/* A table from IPath (from a classpath entry) to HashSet of 
IJavaProject
	 * Used when an IPath corresponds to more than one root */
	Map otherRoots;
	
	/* The java element that was last created (see createElement
(IResource). 
	 * This is used as a stack of java elements (using getParent() to pop 
it, and 
	 * using the various get*(...) to push it. */
	Openable currentElement;
	
	/*
	 * The type of the current event being processed (see 
ChangedElementEvent)
	 */
	int currentEventType;
	
	public HashMap externalTimeStamps = new HashMap();
	public HashSet projectsToUpdate = new HashSet();
	
	JavaModelManager manager;

	static final IJavaElementDelta[] NO_DELTA = new IJavaElementDelta[0];

	public static boolean VERBOSE = false;

	DeltaProcessor(JavaModelManager manager) {
		this.manager = manager;
	}

	/*
	 * Adds the dependents of the given project to the list of the projects
	 * to update.
	 */
	void addDependentsToProjectsToUpdate(IPath projectPath) {
		try {
			IJavaProject[] projects = 
JavaModelManager.getJavaModelManager().getJavaModel().getJavaProjects();
			for (int i = 0, length = projects.length; i &lt; length; 
i++) {
				IJavaProject project = projects[i];
				IClasspathEntry[] classpath = 
project.getResolvedClasspath(true);
				for (int j = 0, length2 = classpath.length; j &lt; 
length2; j++) {
					IClasspathEntry entry = classpath[j];
					if (entry.getEntryKind() == 
IClasspathEntry.CPE_PROJECT
							&amp;&amp; entry.getPath
().equals(projectPath)) {
						this.projectsToUpdate.add
(project);
					}
				}
			}
		} catch (JavaModelException e) {
		}
	}
	/*
	 * Adds the given project and its dependents to the list of the projects
	 * to update.
	 */
	void addToProjectsToUpdateWithDependents(IProject project) {
		this.projectsToUpdate.add(JavaCore.create(project));
		this.addDependentsToProjectsToUpdate(project.getFullPath());
	}
	
	/**
	 * Adds the given child handle to its parent's cache of children. 
	 */
	protected void addToParentInfo(Openable child) {

		Openable parent = (Openable) child.getParent();
		if (parent != null &amp;&amp; parent.isOpen()) {
			try {
				JavaElementInfo info = parent.getElementInfo();
				info.addChild(child);
			} catch (JavaModelException e) {
				// do nothing - we already checked if open
			}
		}
	}



	/**
	 * Check whether the updated file is affecting some of the properties 
of a given project (like
	 * its classpath persisted as a file).
	 * Also force classpath problems to be refresh if not running in 
autobuild mode.
	 * NOTE: It can induce resource changes, and cannot be called during 
POST_CHANGE notification.
	 *
	 */
	public void performPreBuildCheck(
		IResourceDelta delta,
		IJavaElement parent) {
	
		IResource resource = delta.getResource();
		IJavaElement element = JavaCore.create(resource);
		boolean processChildren = false;
	
		switch (resource.getType()) {
	
			case IResource.ROOT :
			case IResource.PROJECT :
				if (delta.getKind() == IResourceDelta.CHANGED) {
					processChildren = true;
				}
				break;
			case IResource.FILE :
				if (parent.getElementType() == 
IJavaElement.JAVA_PROJECT) {
					IFile file = (IFile) resource;
					JavaProject project = (JavaProject) 
parent;
	
					/* check classpath property file change 
*/
					QualifiedName classpathProp;
					if (file.getName().equals(
						
	project.computeSharedPropertyFileName(
								classpathProp = 
project.getClasspathPropertyName()))) {
	
						switch (delta.getKind()) {
							case 
IResourceDelta.REMOVED : // recreate one based on in-memory path
								try {
								
	project.saveClasspath(project.getRawClasspath(), 
project.getOutputLocation());
								} catch 
(JavaModelException e) {
								}
								break;
							case 
IResourceDelta.CHANGED :
								if 
((delta.getFlags() &amp; IResourceDelta.CONTENT) == 0)
								
	break; // only consider content change
							case 
IResourceDelta.ADDED :
								// check if any 
actual difference
								try {
									// 
force to (re)read the property file
									String 
fileClasspathString = project.getSharedProperty(classpathProp);
									if 
(fileClasspathString == null)
									
	break; // did not find the file
								
	IClasspathEntry[] fileEntries = project.readPaths(fileClasspathString);
									if 
(fileEntries == null)
									
	break; // could not read, ignore 
									if 
(project.isClasspathEqualsTo(project.getRawClasspath(), 
project.getOutputLocation(), fileEntries))
									
	break;
	
									// will 
force an update of the classpath/output location based on the file information
									// 
extract out the output location
									IPath 
outputLocation = null;
									if 
(fileEntries != null &amp;&amp; fileEntries.length &gt; 0) {
									
	IClasspathEntry entry = fileEntries[fileEntries.length - 1];
									
	if (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {
										
	outputLocation = entry.getPath();
										
	IClasspathEntry[] copy = new IClasspathEntry[fileEntries.length - 1];
										
	System.arraycopy(fileEntries, 0, copy, 0, copy.length);
										
	fileEntries = copy;
									
	}
									}
									// 
restore output location				
									if 
(outputLocation == null) {
									
	outputLocation = SetClasspathOperation.ReuseOutputLocation;
									}
									try {
									
	project.setRawClasspath(
										
	fileEntries, 
										
	outputLocation, 
										
	null, // monitor
										
	true, // canChangeResource
										
	false, // forceSave
										
	project.getResolvedClasspath(true), // ignoreUnresolvedVariable
										
	true, // needCycleCheck
										
	true); // needValidation
									} catch 
(JavaModelException e) {
									}
								} catch 
(IOException e) {
									break;
								} catch 
(RuntimeException e) {
									break;
								} catch 
(CoreException e) {
									break;
								}
	
						}
					}
				}
				break;
		}
		if (processChildren) {
			IResourceDelta[] children = delta.getAffectedChildren();
			for (int i = 0; i &lt; children.length; i++) {
				performPreBuildCheck(children[i], element);
			}
		}
	}

	/**
	 * Closes the given element, which removes it from the cache of open 
elements.
	 */
	protected static void close(Openable element) {

		try {
			element.close();
		} catch (JavaModelException e) {
			// do nothing
		}
	}


private void cloneCurrentDelta(IJavaProject project, IPackageFragmentRoot root) 
{
	JavaElementDelta delta = (JavaElementDelta)fCurrentDelta.find(root);
	if (delta == null) return;
	JavaElementDelta clone = (JavaElementDelta)delta.clone(project);
	fCurrentDelta.insertDeltaTree(clone.getElement(), clone);
	switch (clone.getKind()) {
		case IJavaElementDelta.ADDED:
			this.addToParentInfo((Openable)clone.getElement());
			break;
		case IJavaElementDelta.REMOVED:
			Openable element = (Openable)clone.getElement();
			if (element.isOpen()) {
				try {
					element.close();
				} catch (JavaModelException e) {
				}
			}
			this.removeFromParentInfo(element);
			break;
	}
}


	/**
	 * Generic processing for elements with changed contents:&lt;ul&gt;
	 * &lt;li&gt;The element is closed such that any subsequent accesses will re-
open
	 * the element reflecting its new structure.
	 * &lt;li&gt;An entry is made in the delta reporting a content change 
(K_CHANGE with F_CONTENT flag set).
	 * &lt;/ul&gt;
	 * Delta argument could be null if processing an external JAR change
	 */
	protected void contentChanged(Openable element, IResourceDelta delta) {

		close(element);
		int flags = IJavaElementDelta.F_CONTENT;
		if (element instanceof JarPackageFragmentRoot){
			flags |= IJavaElementDelta.F_ARCHIVE_CONTENT_CHANGED;
			flags |= IJavaElementDelta.F_CLASSPATH_REORDER; // hack 
for now
		}
		fCurrentDelta.changed(element, flags);
	}
	
	/**
	 * Check all external JARs status and issue a corresponding root delta.
	 * Also triggers index updates
	 */
	public void checkExternalJarChanges(IProgressMonitor monitor) {

		try {
			HashMap externalJARsStatus = new HashMap();
			
			JavaModel model = manager.getJavaModel();		
	
			fCurrentDelta = new JavaElementDelta(model);
			boolean hasDelta = false;
			
			IJavaProject[] projects =model.getOldJavaProjectsList();
			for (int i = 0, length = projects.length; i &lt; length; 
i++) {
				IJavaProject project = projects[i];
				IClasspathEntry[] entries = 
project.getResolvedClasspath(true);
				for (int j = 0; j &lt; entries.length; j++){
					if (entries[j].getEntryKind() == 
IClasspathEntry.CPE_LIBRARY) {
						
						IPath entryPath = entries
[j].getPath();
						String status = (String)
externalJARsStatus.get(entryPath); 
						if (status == null){
							
							// compute shared status
							Object targetLibrary = 
JavaModel.getTarget(project.getProject(), entryPath, true);

							if (targetLibrary == 
null){ // missing JAR
								if 
(this.externalTimeStamps.containsKey(entryPath)){
								
	this.externalTimeStamps.remove(entryPath);
								
	externalJARsStatus.put(entryPath, EXTERNAL_JAR_REMOVED);
									// the 
jar was physically removed: remove the index
								
	indexManager.removeIndex(entryPath);
								}

							} else if 
(targetLibrary instanceof File){ // external JAR

								File 
externalFile = (File)targetLibrary;
								
								// check 
timestamp to figure if JAR has changed in some way
								Long 
oldTimestamp =(Long) this.externalTimeStamps.get(entryPath);
								long 
newTimeStamp = getTimeStamp(externalFile);
								if 
(oldTimestamp != null){

									if 
(newTimeStamp == 0){ // file doesn't exist
									
	externalJARsStatus.put(entryPath, EXTERNAL_JAR_REMOVED);
									
	this.externalTimeStamps.remove(entryPath);
									
	// remove the index
									
	indexManager.removeIndex(entryPath);

									} else 
if (oldTimestamp.longValue() != newTimeStamp){
									
	externalJARsStatus.put(entryPath, EXTERNAL_JAR_CHANGED);
									
	this.externalTimeStamps.put(entryPath, new Long(newTimeStamp));
									
	// first remove the index so that it is forced to be re-indexed
									
	indexManager.removeIndex(entryPath);
									
	// then index the jar
									
	indexManager.indexLibrary(entryPath, project.getProject());
									} else {
									
	externalJARsStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);
									}
								} else {
									if 
(newTimeStamp == 0){ // jar still doesn't exist
									
	externalJARsStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);
									} else {
									
	externalJARsStatus.put(entryPath, EXTERNAL_JAR_ADDED);
									
	this.externalTimeStamps.put(entryPath, new Long(newTimeStamp));
									
	// index the new jar
									
	indexManager.indexLibrary(entryPath, project.getProject());
									}
								}
							} else { // internal JAR
							
	externalJARsStatus.put(entryPath, INTERNAL_JAR_IGNORE);
							}
						}
						// according to computed 
status, generate a delta
						status = (String)
externalJARsStatus.get(entryPath); 
						if (status != null){
							PackageFragmentRoot 
root = (PackageFragmentRoot)project.getPackageFragmentRoot(entryPath.toString
());
							if (status == 
EXTERNAL_JAR_ADDED){
								if (VERBOSE){
								
	System.out.println(&quot;- External JAR ADDED, affecting 
root: &quot;+root.getElementName());
								} 
								elementAdded
(root, null);
								hasDelta = true;
							} else if (status == 
EXTERNAL_JAR_CHANGED) {
								if (VERBOSE){
								
	System.out.println(&quot;- External JAR CHANGED, affecting 
root: &quot;+root.getElementName());
								}
								contentChanged
(root, null);
								hasDelta = true;
							} else if (status == 
EXTERNAL_JAR_REMOVED) {
								if (VERBOSE){
								
	System.out.println(&quot;- External JAR REMOVED, affecting 
root: &quot;+root.getElementName());
								}
								elementRemoved
(root, null);
								hasDelta = true;
							}
						}
					}
				}
			}
			if (hasDelta){
				this.manager.fire(fCurrentDelta, 
JavaModelManager.DEFAULT_CHANGE_EVENT);			
			}
		} catch (JavaModelException e) { // nothing can be done
		} finally {
			fCurrentDelta = null;
		}
	}
	
	/*
	 * Process the given delta and look for projects being added, opened, 
closed or
	 * with a java nature being added or removed.
	 * Note that projects being deleted are checked in deleting(IProject).
	 * In all cases, add the project's dependents to the list of projects 
to update
	 * so that the classpath related markers can be updated.
	 */
	public void checkProjectsBeingAddedOrRemoved(IResourceDelta delta) {
		IResource resource = delta.getResource();
		switch (resource.getType()) {
			case IResource.ROOT :
				// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 15168</a> circular errors not 
reported 
				if (this.manager.javaProjectsCache == null) {
					try {
						this.manager.javaProjectsCache 
= this.manager.getJavaModel().getJavaProjects();
					} catch (JavaModelException e) {
					}
				}
				
				IResourceDelta[] children = 
delta.getAffectedChildren();
				for (int i = 0, length = children.length; i &lt; 
length; i++) {
					this.checkProjectsBeingAddedOrRemoved
(children[i]);
				}
				break;
			case IResource.PROJECT :
				// NB: No need to check project's nature as if 
the project is not a java project:
				//     - if the project is added or changed 
this is a noop for projectsBeingDeleted
				//     - if the project is closed, it has 
already lost its java nature
				int deltaKind = delta.getKind();
				if (deltaKind == IResourceDelta.ADDED) {
					// remember project and its dependents
					IProject project = (IProject)resource;
					this.addToProjectsToUpdateWithDependents
(project);
					
					// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 15168</a> circular 
errors not reported 
					if (this.hasJavaNature(project)) {
						this.addToParentInfo
((JavaProject)JavaCore.create(project));
					}

				} else if (deltaKind == IResourceDelta.CHANGED) 
{
					IProject project = (IProject)resource;
					if ((delta.getFlags() &amp; 
IResourceDelta.OPEN) != 0) {
						// project opened or closed: 
remember  project and its dependents
					
	this.addToProjectsToUpdateWithDependents(project);
						
						// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 15168</a> 
circular errors not reported 
						if (project.isOpen()) {
							if (this.hasJavaNature
(project)) {
							
	this.addToParentInfo((JavaProject)JavaCore.create(project));
							}
						} else {
							JavaProject javaProject 
= (JavaProject)this.manager.getJavaModel().findJavaProject(project);
							if (javaProject != 
null) {
								try {
								
	javaProject.close();
								} catch 
(JavaModelException e) {
								}
							
	this.removeFromParentInfo(javaProject);
							}
						}
					} else if ((delta.getFlags() &amp; 
IResourceDelta.DESCRIPTION) != 0) {
						boolean wasJavaProject = 
this.manager.getJavaModel().findJavaProject(project) != null;
						boolean isJavaProject = 
this.hasJavaNature(project);
						if (wasJavaProject != 
isJavaProject) {
							// java nature added or 
removed: remember  project and its dependents
						
	this.addToProjectsToUpdateWithDependents(project);

							// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 
15168</a> circular errors not reported 
							if (isJavaProject) {
							
	this.addToParentInfo((JavaProject)JavaCore.create(project));
							} else {
								JavaProject 
javaProject = (JavaProject)JavaCore.create(project);
								try {
								
	javaProject.close();
								} catch 
(JavaModelException e) {
								}
							
	this.removeFromParentInfo(javaProject);
							}
						}
					} else {
						// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 15168</a> 
circular errors not reported 
						// in case the project was 
removed then added then changed
						this.addToParentInfo
((JavaProject)JavaCore.create(project));
					}					
				}
				break;
		}
	}

	/**
	 * Creates the openables corresponding to this resource.
	 * Returns null if none was found.
	 */
	protected Openable createElement(IResource resource, int elementType, 
IJavaProject project) {
		if (resource == null) return null;
		
		IPath path = resource.getFullPath();
		IJavaElement element = null;
		switch (elementType) {
			case IJavaElement.JAVA_PROJECT:
				this.popUntilPrefixOf(path);
				if (this.currentElement != null) return 
this.currentElement;
				IProject proj = (IProject)resource;
				boolean isOpened = proj.isOpen();
				if (isOpened &amp;&amp; this.hasJavaNature(proj)) {
					element = project == null ? 
JavaCore.create(proj) : project;
				} else if (!isOpened) {
					if (project == null) {
						project = JavaCore.create(proj);
					}
					if (project.isOpen()) {
						element = project; // java 
project is being closed or removed
					} 
				} // else not a java-project
				break;
			case IJavaElement.PACKAGE_FRAGMENT_ROOT:
				element = project == null ? JavaCore.create
(resource) : project.getPackageFragmentRoot(resource);
				break;
			case IJavaElement.PACKAGE_FRAGMENT:
				// find the element that encloses the resource
				this.popUntilPrefixOf(path);
				
				if (this.currentElement == null) {
					element = 
JavaModelManager.getJavaModelManager().create(resource, project);
				} else {
					// find the root
					IPackageFragmentRoot root = 
this.currentElement.getPackageFragmentRoot();
					if (root == null) {
						element = 
JavaModelManager.getJavaModelManager().create(resource, project);
					} else if (!
JavaModelManager.conflictsWithOutputLocation(path, (JavaProject)
root.getJavaProject())) {
						// create package handle
						IPath pkgPath = 
path.removeFirstSegments(root.getPath().segmentCount());
						String pkg = Util.packageName
(pkgPath);
						if (pkg == null) return null;
						element = 
root.getPackageFragment(pkg);
					}
				}
				break;
			case IJavaElement.COMPILATION_UNIT:
			case IJavaElement.CLASS_FILE:
				// find the element that encloses the resource
				this.popUntilPrefixOf(path);
				
				if (this.currentElement == null) {
					element = element = 
JavaModelManager.getJavaModelManager().create(resource, project);
				} else {
					// find the package
					IPackageFragment pkgFragment = null;
					switch 
(this.currentElement.getElementType()) {
						case 
IJavaElement.PACKAGE_FRAGMENT_ROOT:
							IPackageFragmentRoot 
root = (IPackageFragmentRoot)this.currentElement;
							IPath rootPath = 
root.getPath();
							IPath pkgPath = 
path.removeLastSegments(1);
							String pkgName = 
Util.packageName(pkgPath.removeFirstSegments(rootPath.segmentCount()));
							if (pkgName != null) {
								pkgFragment = 
root.getPackageFragment(pkgName);
							}
							break;
						case 
IJavaElement.PACKAGE_FRAGMENT:
							Openable pkg = 
(Openable)this.currentElement;
							if (pkg.getPath().equals
(path.removeLastSegments(1))) {
								pkgFragment = 
(IPackageFragment)pkg;
							} // else case of 
package x which is a prefix of x.y
							break;
						case 
IJavaElement.COMPILATION_UNIT:
						case IJavaElement.CLASS_FILE:
							pkgFragment = 
(IPackageFragment)this.currentElement.getParent();
							break;
					}
					if (pkgFragment == null) {
						element = 
JavaModelManager.getJavaModelManager().create(resource, project);
					} else {
						if (elementType == 
IJavaElement.COMPILATION_UNIT) {
							// create compilation 
unit handle 
							// fileName validation 
has been done in elementType(IResourceDelta, int, boolean)
							String fileName = 
path.lastSegment();
							element = 
pkgFragment.getCompilationUnit(fileName);
						} else {
							// create class file 
handle
							// fileName validation 
has been done in elementType(IResourceDelta, int, boolean)
							String fileName = 
path.lastSegment();
							element = 
pkgFragment.getClassFile(fileName);
						}
					}
				}
				break;
		}
		if (element == null) {
			return null;
		} else {
			this.currentElement = (Openable)element;
			return this.currentElement;
		}
	}
	/**
	 * Note that the project is about to be deleted.
	 */
	public void deleting(IProject project) {
		
		try {
			JavaProject javaProject = (JavaProject)JavaCore.create
(project);
			javaProject.close();

			// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 15168</a> circular errors not 
reported  
			if (this.manager.javaProjectsCache == null) {
				this.manager.javaProjectsCache = 
this.manager.getJavaModel().getJavaProjects();
			}
			this.removeFromParentInfo(javaProject);

		} catch (JavaModelException e) {
		}
		
		this.addDependentsToProjectsToUpdate(project.getFullPath());
	}

	/**
	 * Processing for an element that has been added:&lt;ul&gt;
	 * &lt;li&gt;If the element is a project, do nothing, and do not process
	 * children, as when a project is created it does not yet have any
	 * natures - specifically a java nature.
	 * &lt;li&gt;If the elemet is not a project, process it as added (see
	 * &lt;code&gt;basicElementAdded&lt;/code&gt;.
	 * &lt;/ul&gt;
	 * Delta argument could be null if processing an external JAR change
	 */
	protected void elementAdded(Openable element, IResourceDelta delta) {
		int elementType = element.getElementType();
		
		if (elementType == IJavaElement.JAVA_PROJECT) {
			// project add is handled by JavaProject.configure() 
because
			// when a project is created, it does not yet have a 
java nature
			if (delta != null &amp;&amp; hasJavaNature((IProject)
delta.getResource())) {
				addToParentInfo(element);
				if ((delta.getFlags() &amp; 
IResourceDelta.MOVED_FROM) != 0) {
					Openable movedFromElement = (Openable)
element.getJavaModel().getJavaProject(delta.getMovedFromPath().lastSegment());
					fCurrentDelta.movedTo(element, 
movedFromElement);
				} else {
					fCurrentDelta.added(element);
				}
				this.projectsToUpdate.add(element);
			}
		} else {			
			addToParentInfo(element);
			
			// Force the element to be closed as it might have been 
opened 
			// before the resource modification came in and it 
might have a new child
			// For example, in an IWorkspaceRunnable:
			// 1. create a package fragment p using a java model 
operation
			// 2. open package p
			// 3. add file X.java in folder p
			// When the resource delta comes in, only the addition 
of p is notified, 
			// but the package p is already opened, thus its 
children are not recomputed
			// and it appears empty.
			close(element);
			
			if (delta != null &amp;&amp; (delta.getFlags() &amp; 
IResourceDelta.MOVED_FROM) != 0) {
				IPath movedFromPath = delta.getMovedFromPath();
				IResource res = delta.getResource();
				IResource movedFromRes;
				if (res instanceof IFile) {
					movedFromRes = res.getWorkspace
().getRoot().getFile(movedFromPath);
				} else {
					movedFromRes = res.getWorkspace
().getRoot().getFolder(movedFromPath);
				}
				
				// find the element type of the moved from 
element
				IJavaProject projectOfRoot = (IJavaProject)
this.roots.get(movedFromPath);
				boolean isPkgFragmentRoot = 
					projectOfRoot != null 
					&amp;&amp; (projectOfRoot.getProject
().getFullPath().isPrefixOf(movedFromPath));
				int movedFromType = 
					this.elementType(
						movedFromRes, 
						delta.getKind(),
						delta.getFlags(),
						element.getParent
().getElementType(), 
						isPkgFragmentRoot);
				
				// create the moved from element
				Openable movedFromElement = 
					elementType != 
IJavaElement.JAVA_PROJECT &amp;&amp; movedFromType == IJavaElement.JAVA_PROJECT ? 
						null : // outside classpath
						this.createElement
(movedFromRes, movedFromType, null); // pass null for the project in case the 
element is moving to another project
				if (movedFromElement == null) {
					// moved from outside classpath
					fCurrentDelta.added(element);
				} else {
					fCurrentDelta.movedTo(element, 
movedFromElement);
				}
			} else {
				fCurrentDelta.added(element);
			}
			
			switch (elementType) {
				case IJavaElement.PACKAGE_FRAGMENT_ROOT :
					// when a root is added, and is on the 
classpath, the project must be updated
					this.projectsToUpdate.add
(element.getJavaProject());
					break;
				case IJavaElement.PACKAGE_FRAGMENT :
					// get rid of namelookup since it holds 
onto obsolete cached info 
					JavaProject project = (JavaProject) 
element.getJavaProject();
					try {
					
	project.getJavaProjectElementInfo().setNameLookup(null);
					} catch (JavaModelException e) {
					}
					// add subpackages
					if (delta != null){
						PackageFragmentRoot root = 
element.getPackageFragmentRoot();
						String name = 
element.getElementName();
						IResourceDelta[] children = 
delta.getAffectedChildren();
						for (int i = 0, length = 
children.length; i &lt; length; i++) {
							IResourceDelta child = 
children[i];
							IResource resource = 
child.getResource();
							if (resource instanceof 
IFolder) {
								String 
subpkgName = 
								
	name.length() == 0 ? 
									
	resource.getName() : 
									
	name + &quot;.&quot; + resource.getName(); //$NON-NLS-1$
								Openable subpkg 
= (Openable)root.getPackageFragment(subpkgName);
								this.updateIndex
(subpkg, child);
							
	this.elementAdded(subpkg, child);
							}
						}
					}
					break;
			}
		}
	}





	/**
	 * Generic processing for a removed element:&lt;ul&gt;
	 * &lt;li&gt;Close the element, removing its structure from the cache
	 * &lt;li&gt;Remove the element from its parent's cache of children
	 * &lt;li&gt;Add a REMOVED entry in the delta
	 * &lt;/ul&gt;
	 * Delta argument could be null if processing an external JAR change
	 */
	protected void elementRemoved(Openable element, IResourceDelta delta) {
		
		if (element.isOpen()) {
			close(element);
		}
		removeFromParentInfo(element);
		int elementType = element.getElementType();
		if (delta != null &amp;&amp; (delta.getFlags() &amp; 
IResourceDelta.MOVED_TO) != 0) {
			IPath movedToPath = delta.getMovedToPath();
			IResource res = delta.getResource();
			IResource movedToRes;
			switch (res.getType()) {
				case IResource.PROJECT:
					movedToRes = res.getWorkspace().getRoot
().getProject(movedToPath.lastSegment());
					break;
				case IResource.FOLDER:
					movedToRes = res.getWorkspace().getRoot
().getFolder(movedToPath);
					break;
				case IResource.FILE:
					movedToRes = res.getWorkspace().getRoot
().getFile(movedToPath);
					break;
				default:
					return;
			}

			// find the element type of the moved from element
			IJavaProject projectOfRoot = (IJavaProject)
this.roots.get(movedToPath);
			boolean isPkgFragmentRoot = 
				projectOfRoot != null 
				&amp;&amp; (projectOfRoot.getProject().getFullPath
().isPrefixOf(movedToPath));
			int movedToType = 
				this.elementType(
					movedToRes, 
					delta.getKind(),
					delta.getFlags(),
					element.getParent().getElementType(), 
					isPkgFragmentRoot);
			
			// create the moved To element
			Openable movedToElement = 
				elementType != IJavaElement.JAVA_PROJECT &amp;&amp; 
movedToType == IJavaElement.JAVA_PROJECT ? 
					null : // outside classpath
					this.createElement(movedToRes, 
movedToType, null); // pass null for the project in case the element is moving 
to another project
			if (movedToElement == null) {
				// moved outside classpath
				fCurrentDelta.removed(element);
			} else {
				fCurrentDelta.movedFrom(element, 
movedToElement);
			}
		} else {
			fCurrentDelta.removed(element);
		}

		switch (elementType) {
			case IJavaElement.JAVA_MODEL :
				this.indexManager.reset();
				break;
			case IJavaElement.JAVA_PROJECT :
				JavaModelManager.getJavaModelManager
().removePerProjectInfo(
					(JavaProject) element);
				break;
			case IJavaElement.PACKAGE_FRAGMENT_ROOT :
				this.projectsToUpdate.add(element.getJavaProject
());
				break;
			case IJavaElement.PACKAGE_FRAGMENT :
				//1G1TW2T - get rid of namelookup since it 
holds onto obsolete cached info 
				JavaProject project = (JavaProject) 
element.getJavaProject();
				try {
					project.getJavaProjectElementInfo
().setNameLookup(null); 
				} catch (JavaModelException e) { 
				}
				// remove subpackages
				if (delta != null){
					PackageFragmentRoot root = 
element.getPackageFragmentRoot();
					String name = element.getElementName();
					IResourceDelta[] children = 
delta.getAffectedChildren();
					for (int i = 0, length = 
children.length; i &lt; length; i++) {
						IResourceDelta child = children
[i];
						IResource resource = 
child.getResource();
						if (resource instanceof 
IFolder) {
							String subpkgName = 
								name.length() 
== 0 ? 
								
	resource.getName() : 
									name 
+ &quot;.&quot; + resource.getName(); //$NON-NLS-1$
							Openable subpkg = 
(Openable)root.getPackageFragment(subpkgName);
							this.updateIndex
(subpkg, child);
							this.elementRemoved
(subpkg, child);
						}
					}
				}
				break;
		}
	}

	/**
	 * Filters the generated &lt;code&gt;JavaElementDelta&lt;/code&gt;s to remove those
	 * which should not be fired (because they don't represent a real change
	 * in the Java Model).
	 */
	protected IJavaElementDelta[] filterRealDeltas(IJavaElementDelta[] 
deltas) {

		int length = deltas.length;
		IJavaElementDelta[] realDeltas = null;
		int index = 0;
		for (int i = 0; i &lt; length; i++) {
			JavaElementDelta delta = (JavaElementDelta)deltas[i];
			if (delta == null) {
				continue;
			}
			if (delta.getAffectedChildren().length &gt; 0
				|| delta.getKind() == IJavaElementDelta.ADDED
				|| delta.getKind() == IJavaElementDelta.REMOVED
				|| (delta.getFlags() &amp; 
IJavaElementDelta.F_CLOSED) != 0
				|| (delta.getFlags() &amp; 
IJavaElementDelta.F_OPENED) != 0
				|| delta.resourceDeltasCounter &gt; 0) {

				if (realDeltas == null) {
					realDeltas = new IJavaElementDelta
[length];
				}
				realDeltas[index++] = delta;
			}
		}
		if (index &gt; 0) {
			IJavaElementDelta[] result = new IJavaElementDelta
[index];
			System.arraycopy(realDeltas, 0, result, 0, index);
			return result;
		} else {
			return NO_DELTA;
		}
	}

	/**
	 * Answer a combination of the lastModified stamp and the size.
	 * Used for detecting external JAR changes
	 */
	public static long getTimeStamp(File file) {
		return file.lastModified() + file.length();
	}
/**
 * Returns true if the given resource is contained in an open project
 * with a java nature, otherwise false.
 */
protected boolean hasJavaNature(IResource resource) {
	// ensure the project has a java nature (if open)
	IProject project = resource.getProject();
	if (project.isOpen()) {
		try {
			return project.hasNature(JavaCore.NATURE_ID);
		} catch (CoreException e) {
			// do nothing
		}
	}
	return false;
}


private JavaModelException newInvalidElementType() {
	return new JavaModelException(new JavaModelStatus
(IJavaModelStatusConstants.INVALID_ELEMENT_TYPES));
}
	/**
	 * Generic processing for elements with changed contents:&lt;ul&gt;
	 * &lt;li&gt;The element is closed such that any subsequent accesses will re-
open
	 * the element reflecting its new structure.
	 * &lt;li&gt;An entry is made in the delta reporting a content change 
(K_CHANGE with F_CONTENT flag set).
	 * &lt;/ul&gt;
	 */
	protected void nonJavaResourcesChanged(Openable element, IResourceDelta 
delta)
		throws JavaModelException {

		// reset non-java resources if element was open
		if (element.isOpen()) {
			JavaElementInfo info = element.getElementInfo();
			switch (element.getElementType()) {
				case IJavaElement.JAVA_PROJECT :
					((JavaProjectElementInfo) 
info).setNonJavaResources(null);
	
					// if a package fragment root is the 
project, clear it too
					PackageFragmentRoot projectRoot =
						(PackageFragmentRoot) 
((JavaProject) element).getPackageFragmentRoot(
							new Path
(IPackageFragment.DEFAULT_PACKAGE_NAME));
					if (projectRoot.isOpen()) {
						((PackageFragmentRootInfo) 
projectRoot.getElementInfo()).setNonJavaResources(
							null);
					}
					break;
				case IJavaElement.PACKAGE_FRAGMENT :
					 ((PackageFragmentInfo) 
info).setNonJavaResources(null);
					break;
				case IJavaElement.PACKAGE_FRAGMENT_ROOT :
					 ((PackageFragmentRootInfo) 
info).setNonJavaResources(null);
			}
		}

		JavaElementDelta elementDelta = fCurrentDelta.find(element);
		if (elementDelta == null) {
			fCurrentDelta.changed(element, 
IJavaElementDelta.F_CONTENT);
			elementDelta = fCurrentDelta.find(element);
		}
		elementDelta.addResourceDelta(delta);
	}
	private void popUntilPrefixOf(IPath path) {
		while (this.currentElement != null) {
			IPath currentElementPath = null;
			if (this.currentElement instanceof 
IPackageFragmentRoot) {
				currentElementPath = ((IPackageFragmentRoot)
this.currentElement).getPath();
			} else {
				IResource currentElementResource = null;
				try {
					currentElementResource = 
this.currentElement.getUnderlyingResource();
				} catch (JavaModelException e) {
				}
				if (currentElementResource != null) {
					currentElementPath = 
currentElementResource.getFullPath();
				}
			}
			if (currentElementPath != null) {
				if (this.currentElement instanceof 
IPackageFragment 
					&amp;&amp; this.currentElement.getElementName
().length() == 0
					&amp;&amp; currentElementPath.segmentCount() != 
path.segmentCount()-1) {
						// default package and path is 
not a direct child
						this.currentElement = (Openable)
this.currentElement.getParent();
				}
				if (currentElementPath.isPrefixOf(path)) {
					return;
				}
			}
			this.currentElement = (Openable)
this.currentElement.getParent();
		}
	}
	
	/**
	 * Converts a &lt;code&gt;IResourceDelta&lt;/code&gt; rooted in a 
&lt;code&gt;Workspace&lt;/code&gt; into
	 * the corresponding set of &lt;code&gt;IJavaElementDelta&lt;/code&gt;, rooted in 
the
	 * relevant &lt;code&gt;JavaModel&lt;/code&gt;s.
	 */
	public IJavaElementDelta[] processResourceDelta(IResourceDelta changes, 
int eventType) {

		try {
			this.currentEventType = eventType;
			IJavaModel model = JavaModelManager.getJavaModelManager
().getJavaModel();
			if (!model.isOpen()) {
				// force opening of java model so that java 
element delta are reported
				try {
					model.open(null);
				} catch (JavaModelException e) {
					if (VERBOSE) {
						e.printStackTrace();
					}
					return NO_DELTA;
				}
			}
			this.initializeRoots(model);
			this.currentElement = null;
			
			// get the workspace delta, and start processing there.
			IResourceDelta[] deltas = changes.getAffectedChildren();
			IJavaElementDelta[] translatedDeltas = new 
JavaElementDelta[deltas.length];
			for (int i = 0; i &lt; deltas.length; i++) {
				IResourceDelta delta = deltas[i];
				IResource res = delta.getResource();
				fCurrentDelta = new JavaElementDelta(model);
				
				// find out whether the delta is a package 
fragment root
				IJavaProject projectOfRoot = (IJavaProject)
this.roots.get(res.getFullPath());
				boolean isPkgFragmentRoot = projectOfRoot != 
null;
				int elementType = 
					this.elementType(
						res, 
						delta.getKind(),
						delta.getFlags(),
						IJavaElement.JAVA_MODEL, 
						isPkgFragmentRoot);
				
				this.traverseDelta(delta, elementType, 
projectOfRoot, null, IGNORE); // traverse delta
				translatedDeltas[i] = fCurrentDelta;
			}
			
			// update package fragment roots of projects that were 
affected
			Iterator iterator = this.projectsToUpdate.iterator();
			while (iterator.hasNext()) {
				JavaProject project = (JavaProject)iterator.next
();
				project.updatePackageFragmentRoots();
			}
	
			return filterRealDeltas(translatedDeltas);
		} finally {
			this.projectsToUpdate = new HashSet();
		}
	}
	
/*
 * Update the current delta (ie. add/remove/change the given element) and 
update the correponding index.
 * Returns whether the children of the given delta must be processed.
 * &#64;throws a JavaModelException if the delta doesn't correspond to a java 
element of the given type.
 */
private boolean updateCurrentDeltaAndIndex(IResourceDelta delta, int 
elementType, IJavaProject project) throws JavaModelException {
	Openable element;
	switch (delta.getKind()) {
		case IResourceDelta.ADDED :
			element = this.createElement(delta.getResource(), 
elementType, project);
			if (element == null) throw newInvalidElementType();
			this.updateIndex(element, delta);
			this.elementAdded(element, delta);
			return false;
		case IResourceDelta.REMOVED :
			element = this.createElement(delta.getResource(), 
elementType, project);
			if (element == null) throw newInvalidElementType();
			this.updateIndex(element, delta);
			this.elementRemoved(element, delta);
			return false;
		case IResourceDelta.CHANGED :
			int flags = delta.getFlags();
			if ((flags &amp; IResourceDelta.CONTENT) != 0) {
				// content has changed
				element = this.createElement(delta.getResource
(), elementType, project);
				if (element == null) throw newInvalidElementType
();
				this.updateIndex(element, delta);
				this.contentChanged(element, delta);
			} else if (elementType == IJavaElement.JAVA_PROJECT) {
				if ((flags &amp; IResourceDelta.OPEN) != 0) {
					// project has been opened or closed
					IProject res = (IProject)
delta.getResource();
					element = this.createElement(res, 
elementType, project);
					if (element == null) throw 
newInvalidElementType();
					if (res.isOpen()) {
						if (this.hasJavaNature(res)) {
							this.elementAdded
(element, delta);
						
	this.indexManager.indexAll(res);
						}
					} else {
						JavaModel javaModel = 
JavaModelManager.getJavaModelManager().getJavaModel();
						boolean wasJavaProject = 
javaModel.findJavaProject(res) != null;
						if (wasJavaProject) {
							this.elementRemoved
(element, delta);
						
	this.indexManager.discardJobs(element.getElementName());
						
	this.indexManager.removeIndex(res.getFullPath());
							
						}
					}
					return false; // when a project is 
open/closed don't process children
				}
				if ((flags &amp; IResourceDelta.DESCRIPTION) != 0) {
					IProject res = (IProject)
delta.getResource();
					JavaModel javaModel = 
JavaModelManager.getJavaModelManager().getJavaModel();
					boolean wasJavaProject = 
javaModel.findJavaProject(res) != null;
					boolean isJavaProject = 
this.hasJavaNature(res);
					if (wasJavaProject != isJavaProject) {
						// project's nature has been 
added or removed
						element = this.createElement
(res, elementType, project);
						if (element == null) throw 
newInvalidElementType();
						if (isJavaProject) {
							this.elementAdded
(element, delta);
						
	this.indexManager.indexAll(res);
						} else {
							this.elementRemoved
(element, delta);
						
	this.indexManager.discardJobs(element.getElementName());
						
	this.indexManager.removeIndex(res.getFullPath());
						}
						return false; // when a 
project's nature is added/removed don't process children
					}
				}
			}
			return true;
	}
	return true;
}

	/**
	 * Removes the given element from its parents cache of children. If the
	 * element does not have a parent, or the parent is not currently open,
	 * this has no effect. 
	 */
	protected void removeFromParentInfo(Openable child) {

		Openable parent = (Openable) child.getParent();
		if (parent != null &amp;&amp; parent.isOpen()) {
			try {
				JavaElementInfo info = parent.getElementInfo();
				info.removeChild(child);
			} catch (JavaModelException e) {
				// do nothing - we already checked if open
			}
		}
	}
	/**
	 * Notification that some resource changes have happened
	 * on the platform, and that the Java Model should update any required
	 * internal structures such that its elements remain consistent.
	 * Translates &lt;code&gt;IResourceDeltas&lt;/code&gt; into 
&lt;code&gt;IJavaElementDeltas&lt;/code&gt;.
	 *
	 * &#64;see IResourceDelta
	 * &#64;see IResource 
	 */
	public void resourceChanged(IResourceChangeEvent event) {

		JavaModelManager.IsResourceTreeLocked = false;
		
		if (event.getSource() instanceof IWorkspace) {
			IResource resource = event.getResource();
			IResourceDelta delta = event.getDelta();
			
			switch(event.getType()){
				case IResourceChangeEvent.PRE_DELETE :
					try {
						if(resource.getType() == 
IResource.PROJECT 
							&amp;&amp; ((IProject) 
resource).hasNature(JavaCore.NATURE_ID)) {
								
							this.deleting((IProject)
resource);
						}
					} catch(CoreException e){
					}
					return;
					
				case IResourceChangeEvent.PRE_AUTO_BUILD :
					if(delta != null) {
					
	this.checkProjectsBeingAddedOrRemoved(delta);
						
						// update the classpath related 
markers
						this.updateClasspathMarkers();

						// the following will close 
project if affected by the property file change
						this.performPreBuildCheck
(delta, null); 
					}
					// only fire already computed deltas 
(resource ones will be processed in post change only)
					this.manager.fire(null, 
ElementChangedEvent.PRE_AUTO_BUILD);
					break;
					
				case IResourceChangeEvent.POST_CHANGE :
					try {
					
	JavaModelManager.IsResourceTreeLocked = true;
						if (delta != null) {
							IJavaElementDelta[] 
translatedDeltas = this.processResourceDelta(delta, 
ElementChangedEvent.POST_CHANGE);
							if 
(translatedDeltas.length &gt; 0) { 
								for (int i= 0; 
i &lt; translatedDeltas.length; i++) {
								
	this.manager.registerJavaModelDelta(translatedDeltas[i]);
								}
							}
							this.manager.fire(null, 
ElementChangedEvent.POST_CHANGE);
						}		
					} finally {
						// workaround for <a class="bz_bug_link 
          bz_status_RESOLVED  bz_closed"
   title="RESOLVED FIXED - circular errors not reported"
   href="show_bug.cgi?id=15168">bug 15168</a> 
circular errors not reported 
						this.manager.javaProjectsCache 
= null;
					
	JavaModelManager.IsResourceTreeLocked = false;
					}
			}
		}
	}

	/**
	 * Converts an &lt;code&gt;IResourceDelta&lt;/code&gt; and its children into
	 * the corresponding &lt;code&gt;IJavaElementDelta&lt;/code&gt;s.
	 * Return whether the delta corresponds to a resource on the classpath.
	 * If it is not a resource on the classpath, it will be added as a non-
java
	 * resource by the sender of this method.
	 */
	protected boolean traverseDelta(
		IResourceDelta delta, 
		int elementType, 
		IJavaProject currentProject,
		IPath currentOutput,
		int outputTraverseMode) {
			
		IResource res = delta.getResource();
		
		// process current delta
		boolean processChildren = true;
		if (currentProject != null || res instanceof IProject) {
			if (this.currentElement == null || !
this.currentElement.getJavaProject().equals(currentProject)) {
				// force the currentProject to be used
				this.currentElement = (Openable)currentProject;
			}
			try {
				processChildren = 
this.updateCurrentDeltaAndIndex(delta, elementType, currentProject);
			} catch (JavaModelException e) {
				// non java resource or invalid project
				return false;
			}
		} else {
			// not yet inside a package fragment root
			processChildren = true;
		}
		
		// get the project's output location
		if (currentOutput == null) {
			try {
				IJavaProject proj =
					currentProject == null ?
						(IJavaProject)this.createElement
(res.getProject(), IJavaElement.JAVA_PROJECT, null) :
						currentProject;
				if (proj != null) {
					currentOutput = proj.getOutputLocation
();
					if (proj.getProject().getFullPath
().equals(currentOutput)){ // case of proj==bin==src
						outputTraverseMode = SOURCE;
					} else {
						// check case of src==bin
						IClasspathEntry[] classpath = 
proj.getResolvedClasspath(true);
						for (int i = 0, length = 
classpath.length; i &lt; length; i++) {
							IClasspathEntry entry = 
classpath[i];
							if (entry.getPath
().equals(currentOutput)) {
							
	outputTraverseMode = (entry.getEntryKind() == 
IClasspathEntry.CPE_SOURCE) ? SOURCE : BINARY;
								break;
							}
						}
					}
				}
			} catch (JavaModelException e) {
			}
		}

		// process children if needed
		if (processChildren) {
			IResourceDelta[] children = delta.getAffectedChildren();
			boolean oneChildOnClasspath = false;
			int length = children.length;
			IResourceDelta[] orphanChildren = new IResourceDelta
[length];
			Openable parent = null;
			boolean isValidParent = true;
			for (int i = 0; i &lt; length; i++) {
				IResourceDelta child = children[i];
				IResource childRes = child.getResource();
				IPath childPath = childRes.getFullPath();

				// find out whether the child is a package 
fragment root of the current project
				IJavaProject projectOfRoot = (IJavaProject)
this.roots.get(childPath);
				boolean isPkgFragmentRoot = 
					projectOfRoot != null 
					&amp;&amp; (projectOfRoot.getProject
().getFullPath().isPrefixOf(childPath));
				int childType = 
					this.elementType(
						childRes, 
						child.getKind(),
						child.getFlags(),
						elementType, 
						isPkgFragmentRoot);
				
				// filter out changes in output location
				if (currentOutput != null &amp;&amp; 
currentOutput.isPrefixOf(childPath)) {
					if (outputTraverseMode != IGNORE) {
						// case of bin=src
						if (outputTraverseMode == 
SOURCE &amp;&amp; childType == IJavaElement.CLASS_FILE) {
							continue;
						}
						// case of .class file under 
project and no source folder
						// proj=bin
						if (childType == 
IJavaElement.JAVA_PROJECT 
							&amp;&amp; childRes instanceof 
IFile 
							&amp;&amp; 
Util.isValidClassFileName(childRes.getName())) {
							continue;
						}
					} else {
						continue;
					}
				}
				
				// traverse delta for child in the same project
				if (childType == -1
					|| !this.traverseDelta(child, 
childType, (currentProject == null &amp;&amp; isPkgFragmentRoot) ? projectOfRoot : 
currentProject, currentOutput, outputTraverseMode)) {
					try {
						if (currentProject != null) {
							if (!isValidParent) 
continue; 
							if (parent == null) {
								if 
(this.currentElement == null || !this.currentElement.getJavaProject().equals
(currentProject)) {
									// 
force the currentProject to be used
								
	this.currentElement = (Openable)currentProject;
								}
								if (elementType 
== IJavaElement.JAVA_PROJECT
									|| 
(elementType == IJavaElement.PACKAGE_FRAGMENT_ROOT &amp;&amp; res instanceof IProject)) 
{ 
									// NB: 
attach non-java resource to project (not to its package fragment root)
									parent 
= (Openable)currentProject;
								} else {
									parent 
= this.createElement(res, elementType, currentProject);
								}
								if (parent == 
null) {
								
	isValidParent = false;
								
	continue;
								}
							}
							// add child as non 
java resource
							nonJavaResourcesChanged
(parent, child);
						} else {
							orphanChildren[i] = 
child;
						}
					} catch (JavaModelException e) {
					}
				} else {
					oneChildOnClasspath = true;
				}
				
				// if child is a package fragment root of 
another project, traverse delta too
				if (projectOfRoot != null &amp;&amp; !
isPkgFragmentRoot) {
					this.traverseDelta(child, 
IJavaElement.PACKAGE_FRAGMENT_ROOT, projectOfRoot, null, IGNORE); // binary 
output of projectOfRoot cannot be this root
					// NB: No need to check the return 
value as the child can only be on the classpath
				}
				
				// if the child is a package fragment root of 
one or several other projects
				HashSet set;
				if ((set = (HashSet)this.otherRoots.get
(childPath)) != null) {
					IPackageFragmentRoot currentRoot = 
						(currentProject == null ? 
							projectOfRoot : 
						
	currentProject).getPackageFragmentRoot(childRes);
					Iterator iterator = set.iterator();
					while (iterator.hasNext()) {
						IJavaProject project = 
(IJavaProject) iterator.next();
						this.cloneCurrentDelta(project, 
currentRoot);
					}
				}
			}
			if (oneChildOnClasspath || res instanceof IProject) {
				// add orphan children (case of non java 
resources under project)
				JavaProject adoptiveProject = (JavaProject)
JavaCore.getJavaCore().create(res.getProject());
				if (adoptiveProject != null) {
					for (int i = 0; i &lt; length; i++) {
						if (orphanChildren[i] != null) {
							try {
							
	nonJavaResourcesChanged(adoptiveProject, orphanChildren[i]);
							} catch 
(JavaModelException e) {
							}
						}
					}
				}
			} // else resource delta will be added by parent
			return isValidParent &amp;&amp; (currentProject != null || 
oneChildOnClasspath);
		} else {
			// if not on classpath or if the element type is -1, 
			// it's a non-java resource
			return currentProject != null &amp;&amp; elementType != -1;
		}
	}
	/**
	 * Update the classpath markers and cycle markers for the projects to 
update.
	 */
	void updateClasspathMarkers() {
		try {
			if (!ResourcesPlugin.getWorkspace().isAutoBuilding()) {
				Iterator iterator = 
this.projectsToUpdate.iterator();
				while (iterator.hasNext()) {
					try {
						JavaProject project = 
(JavaProject)iterator.next();
						
						 // force classpath marker 
refresh
						project.getResolvedClasspath(
							true, // 
ignoreUnresolvedEntry
							true); // 
generateMarkerOnError
						
					} catch (JavaModelException e) {
					}
				}
			}
			if (!this.projectsToUpdate.isEmpty()){
				try {
					// update all cycle markers
					JavaProject.updateAllCycleMarkers();
				} catch (JavaModelException e) {
				}
			}				
		} finally {
			this.projectsToUpdate = new HashSet();
		}
	
	}

	/*
	 * Returns the type of the java element the given delta matches to.
	 * Returns -1 if unknown (e.g. a non-java resource.)
	 */
	private int elementType(IResource res, int kind, int flags, int 
parentType, boolean isPkgFragmentRoot) {
		switch (parentType) {
			case IJavaElement.JAVA_MODEL:
				if (kind != IResourceDelta.CHANGED
					|| (flags &amp; IResourceDelta.OPEN) != 0
					|| (flags &amp; 
IResourceDelta.DESCRIPTION) != 0) {
					// project is added, removed, opened or 
closed, or its nature is changed
					return IJavaElement.JAVA_PROJECT;
				} // else see below
			case IJavaElement.JAVA_PROJECT:
				if (isPkgFragmentRoot) {
					return 
IJavaElement.PACKAGE_FRAGMENT_ROOT;
				} else {
					return IJavaElement.JAVA_PROJECT; // 
not yet in a package fragment root
				}
			case IJavaElement.PACKAGE_FRAGMENT_ROOT:
			case IJavaElement.PACKAGE_FRAGMENT:
				if (res instanceof IFolder) {
					if (Util.isValidFolderNameForPackage
(res.getName())) {
						return 
IJavaElement.PACKAGE_FRAGMENT;
					} else {
						return -1;
					}
				} else {
					String fileName = res.getName();
					if (Util.isValidCompilationUnitName
(fileName)) {
						return 
IJavaElement.COMPILATION_UNIT;
					} else if (Util.isValidClassFileName
(fileName)) {
						return IJavaElement.CLASS_FILE;
					} else if (this.roots.get
(res.getFullPath()) != null) {
						// case of proj=src=bin and 
resource is a jar file on the classpath
						return 
IJavaElement.PACKAGE_FRAGMENT_ROOT;
					} else {
						return -1;
					}
				}
			default:
				return -1;
		}
	}
	
private void initializeRoots(IJavaModel model) {
	this.roots = new HashMap();
	this.otherRoots = new HashMap();
	IJavaProject[] projects;
	try {
		projects = ((JavaModel)model).getOldJavaProjectsList();
	} catch (JavaModelException e) {
		// nothing can be done
		return;
	}
	for (int i = 0, length = projects.length; i &lt; length; i++) {
		IJavaProject project = projects[i];
		IClasspathEntry[] classpath;
		try {
			classpath = project.getResolvedClasspath(true);
		} catch (JavaModelException e) {
			// continue with next project
			continue;
		}
		for (int j= 0, classpathLength = classpath.length; j &lt; 
classpathLength; j++) {
			IClasspathEntry entry = classpath[j];
			if (entry.getEntryKind() == 
IClasspathEntry.CPE_PROJECT) continue;
			IPath path = entry.getPath();
			if (this.roots.get(path) == null) {
				this.roots.put(path, project);
			} else {
				HashSet set = (HashSet)this.otherRoots.get
(path);
				if (set == null) {
					set = new HashSet();
					this.otherRoots.put(path, set);
				}
				set.add(project);
			}
		}
	}
}

private boolean isOnClasspath(IPath path) {
	return this.roots.get(path) != null;
}

protected void updateIndex(Openable element, IResourceDelta delta) {

	if (indexManager == null)
		return;

	switch (element.getElementType()) {
		case IJavaElement.JAVA_PROJECT :
			switch (delta.getKind()) {
				case IResourceDelta.ADDED :
					this.indexManager.indexAll
(element.getJavaProject().getProject());
					break;
				case IResourceDelta.REMOVED :
					this.indexManager.discardJobs
(element.getElementName());
					this.indexManager.removeIndex
(element.getJavaProject().getProject().getFullPath());
					break;
				// NB: Update of index if project is opened, 
closed, or its java nature is added or removed
				//     is done in updateCurrentDeltaAndIndex
			}
			break;
		case IJavaElement.PACKAGE_FRAGMENT_ROOT :
			if (element instanceof JarPackageFragmentRoot) {
				JarPackageFragmentRoot root = 
(JarPackageFragmentRoot)element;
				// index jar file only once (if the root is in 
its declaring project)
				IPath jarPath = root.getPath();
				switch (delta.getKind()) {
					case IResourceDelta.ADDED:
						// index the new jar
						indexManager.indexLibrary
(jarPath, root.getJavaProject().getProject());
						break;
					case IResourceDelta.CHANGED:
						// first remove the index so 
that it is forced to be re-indexed
						indexManager.removeIndex
(jarPath);
						// then index the jar
						indexManager.indexLibrary
(jarPath, root.getJavaProject().getProject());
						break;
					case IResourceDelta.REMOVED:
						// the jar was physically 
removed: remove the index
						indexManager.removeIndex
(jarPath);
						break;
				}
				break;
			} else {
				int kind = delta.getKind();
				if (kind == IResourceDelta.ADDED || kind == 
IResourceDelta.REMOVED) {
					IPackageFragmentRoot root = 
(IPackageFragmentRoot)element;
					this.updateRootIndex(root, 
root.getPackageFragment(&quot;&quot;), delta); //$NON-NLS-1$
					break;
				}
			}
			// don't break as packages of the package fragment root 
can be indexed below
		case IJavaElement.PACKAGE_FRAGMENT :
			switch (delta.getKind()) {
				case IResourceDelta.ADDED:
				case IResourceDelta.REMOVED:
					IPackageFragment pkg = null;
					if (element instanceof 
IPackageFragmentRoot) {
						IPackageFragmentRoot root = 
(IPackageFragmentRoot)element;
						pkg = root.getPackageFragment
(&quot;&quot;); //$NON-NLS-1$
					} else {
						pkg = (IPackageFragment)element;
					}
					IResourceDelta[] children = 
delta.getAffectedChildren();
					for (int i = 0, length = 
children.length; i &lt; length; i++) {
						IResourceDelta child = children
[i];
						IResource resource = 
child.getResource();
						if (resource instanceof IFile) {
							String extension = 
resource.getFileExtension();
							if 
(&quot;java&quot;.equalsIgnoreCase(extension)) { //$NON-NLS-1$
								Openable cu = 
(Openable)pkg.getCompilationUnit(resource.getName());
								this.updateIndex
(cu, child);
							} else if 
(&quot;class&quot;.equalsIgnoreCase(extension)) { //$NON-NLS-1$
								Openable 
classFile = (Openable)pkg.getClassFile(resource.getName());
								this.updateIndex
(classFile, child);
							}
						}
					}
					break;
			}
			break;
		case IJavaElement.CLASS_FILE :
			IFile file = (IFile) delta.getResource();
			IJavaProject project = element.getJavaProject();
			IPath binaryFolderPath = element.getPackageFragmentRoot
().getPath();
			// if the class file is part of the binary output, it 
has been created by
			// the java builder -&gt; ignore
			try {
				if (binaryFolderPath.equals
(project.getOutputLocation())) {
					break;
				}
			} catch (JavaModelException e) {
			}
			switch (delta.getKind()) {
				case IResourceDelta.CHANGED :
					// no need to index if the content has 
not changed
					if ((delta.getFlags() &amp; 
IResourceDelta.CONTENT) == 0)
						break;
				case IResourceDelta.ADDED :
					indexManager.addBinary(file, 
binaryFolderPath);
					break;
				case IResourceDelta.REMOVED :
					indexManager.remove(file.getFullPath
().toString(), binaryFolderPath);
					break;
			}
			break;
		case IJavaElement.COMPILATION_UNIT :
			file = (IFile) delta.getResource();
			switch (delta.getKind()) {
				case IResourceDelta.CHANGED :
					// no need to index if the content has 
not changed
					if ((delta.getFlags() &amp; 
IResourceDelta.CONTENT) == 0)
						break;
				case IResourceDelta.ADDED :
					indexManager.addSource(file, 
file.getProject().getProject().getFullPath());
					break;
				case IResourceDelta.REMOVED :
					indexManager.remove(file.getFullPath
().toString(), file.getProject().getProject().getFullPath());
					break;
			}
	}
}
/**
 * Upadtes the index of the given root (assuming it's an addition or a removal).
 * This is done recusively, pkg being the current package.
 */
private void updateRootIndex(IPackageFragmentRoot root, IPackageFragment pkg, 
IResourceDelta delta) {
	this.updateIndex((Openable)pkg, delta);
	IResourceDelta[] children = delta.getAffectedChildren();
	String name = pkg.getElementName();
	for (int i = 0, length = children.length; i &lt; length; i++) {
		IResourceDelta child = children[i];
		IResource resource = child.getResource();
		if (resource instanceof IFolder) {
			String subpkgName = 
				name.length() == 0 ? 
					resource.getName() : 
					name + &quot;.&quot; + resource.getName(); //$NON-
NLS-1$
			IPackageFragment subpkg = root.getPackageFragment
(subpkgName);
			this.updateRootIndex(root, subpkg, child);
		}
	}
}

}
]</pre>
    </div>

    <div id="c2" class="bz_comment">

      <div class="bz_comment_head">


        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=16570#c2">Comment 2</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Andre Weinand</span> <a href="http://wiki.eclipse.org/ECA"><img class="cla_dec" src="https://accounts.eclipse.org/user/eca/badge?mail=andre_weinand&#64;ch.ibm.com" alt="CLA" title="Eclipse Contributor Agreement" /></a> <a href="https://eclipse.org/donate/"><img class="cla_dec" src="//www.eclipse.org/donate/web-api/friends_decorator.php?email=andre_weinand&#64;ch.ibm.com" alt="Friend" title="Friend of Eclipse" /></a>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2002-06-01 04:47:05 EDT
        </span>

      </div>




<pre class="bz_comment_text">Fixed for 20020601
I couldn't verify the fix with the inlined files because they were heaviliy 
reformatted by Bugzilla.
Please include test input as attachments.</pre>
    </div>

    <div id="c3" class="bz_comment">

      <div class="bz_comment_head">


        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=16570#c3">Comment 3</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Erich Gamma</span> <a href="http://wiki.eclipse.org/ECA"><img class="cla_dec" src="https://accounts.eclipse.org/user/eca/badge?mail=erich_gamma&#64;ch.ibm.com" alt="CLA" title="Eclipse Contributor Agreement" /></a> <a href="https://eclipse.org/donate/"><img class="cla_dec" src="//www.eclipse.org/donate/web-api/friends_decorator.php?email=erich_gamma&#64;ch.ibm.com" alt="Friend" title="Friend of Eclipse" /></a>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2002-06-02 17:49:43 EDT
        </span>

      </div>




<pre class="bz_comment_text">pls verify</pre>
    </div>

    <div id="c4" class="bz_comment">

      <div class="bz_comment_head">


        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=16570#c4">Comment 4</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Dani Megert</span> <a href="http://wiki.eclipse.org/ECA"><img class="cla_dec" src="https://accounts.eclipse.org/user/eca/badge?mail=daniel_megert&#64;ch.ibm.com" alt="CLA" title="Eclipse Contributor Agreement" /></a> <a href="https://eclipse.org/donate/"><img class="cla_dec" src="//www.eclipse.org/donate/web-api/friends_decorator.php?email=daniel_megert&#64;ch.ibm.com" alt="Friend" title="Friend of Eclipse" /></a>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2002-06-03 05:38:40 EDT
        </span>

      </div>




<pre class="bz_comment_text">Need to clear resolution due to bugzilla bug (it changed the resolution to NEW)
</pre>
    </div>

    <div id="c5" class="bz_comment">

      <div class="bz_comment_head">


        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=16570#c5">Comment 5</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Dani Megert</span> <a href="http://wiki.eclipse.org/ECA"><img class="cla_dec" src="https://accounts.eclipse.org/user/eca/badge?mail=daniel_megert&#64;ch.ibm.com" alt="CLA" title="Eclipse Contributor Agreement" /></a> <a href="https://eclipse.org/donate/"><img class="cla_dec" src="//www.eclipse.org/donate/web-api/friends_decorator.php?email=daniel_megert&#64;ch.ibm.com" alt="Friend" title="Friend of Eclipse" /></a>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2002-06-03 05:41:39 EDT
        </span>

      </div>




<pre class="bz_comment_text">Marking bug as fixed again (due to bugzilla bug)
</pre>
    </div>

    <div id="c6" class="bz_comment">

      <div class="bz_comment_head">


        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=16570#c6">Comment 6</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Dani Megert</span> <a href="http://wiki.eclipse.org/ECA"><img class="cla_dec" src="https://accounts.eclipse.org/user/eca/badge?mail=daniel_megert&#64;ch.ibm.com" alt="CLA" title="Eclipse Contributor Agreement" /></a> <a href="https://eclipse.org/donate/"><img class="cla_dec" src="//www.eclipse.org/donate/web-api/friends_decorator.php?email=daniel_megert&#64;ch.ibm.com" alt="Friend" title="Friend of Eclipse" /></a>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2002-06-03 12:19:00 EDT
        </span>

      </div>




<pre class="bz_comment_text">Worked when verifying with my example but as André wrote we can't use the
inlined code.

Please verify this bug.
</pre>
    </div>

    <div id="c7" class="bz_comment">

      <div class="bz_comment_head">


        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=16570#c7">Comment 7</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Philipe Mulet</span> <a href="http://wiki.eclipse.org/ECA"><img class="cla_dec" src="https://accounts.eclipse.org/user/eca/badge?mail=philippe_mulet&#64;fr.ibm.com" alt="CLA" title="Eclipse Contributor Agreement" /></a> <a href="https://eclipse.org/donate/"><img class="cla_dec" src="//www.eclipse.org/donate/web-api/friends_decorator.php?email=philippe_mulet&#64;fr.ibm.com" alt="Friend" title="Friend of Eclipse" /></a>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2002-07-17 05:17:44 EDT
        </span>

      </div>




<pre class="bz_comment_text">Unfortunately, I cannot find the original testcase anymore (my local history 
claims it is empty for it... !?). I remember though that the format difference 
occurred due to grabbing some code from a proposed fix inside a bugzilla report.</pre>
    </div>

    <div id="c8" class="bz_comment">

      <div class="bz_comment_head">


        <span class="bz_comment_number">
          <a 
             href="show_bug.cgi?id=16570#c8">Comment 8</a>
        </span>

        <span class="bz_comment_user">
          <span class="vcard"><span class="fn">Andre Weinand</span> <a href="http://wiki.eclipse.org/ECA"><img class="cla_dec" src="https://accounts.eclipse.org/user/eca/badge?mail=andre_weinand&#64;ch.ibm.com" alt="CLA" title="Eclipse Contributor Agreement" /></a> <a href="https://eclipse.org/donate/"><img class="cla_dec" src="//www.eclipse.org/donate/web-api/friends_decorator.php?email=andre_weinand&#64;ch.ibm.com" alt="Friend" title="Friend of Eclipse" /></a>
</span>
        </span>

        <span class="bz_comment_user_images">
        </span>

        <span class="bz_comment_time">
          2003-02-10 08:54:16 EST
        </span>

      </div>




<pre class="bz_comment_text">Verified by Daniel Megert.</pre>
    </div>


  

</td>
<td>
</td>
</tr></table>
  </div>
        

</form>

<hr>
<ul class="related_actions">
    <li><a href="show_bug.cgi?format=multiple&amp;id=16570">Format For Printing</a></li>
    <li>&nbsp;-&nbsp;<a href="show_bug.cgi?ctype=xml&amp;id=16570">XML</a></li>
    <li>&nbsp;-&nbsp;<a href="enter_bug.cgi?cloned_bug_id=16570">Clone This Bug</a></li>
    
    <li>&nbsp;-&nbsp;<a href="#">Top of page </a></li>
    </ul>

<br>
</div>

    <div id="footer">
      <div class="intro"></div>
<ul id="useful-links">
  <li id="links-actions"><ul class="links">
  <li><a href="./">Home</a></li>
  <li><span class="separator">| </span><a href="enter_bug.cgi">New</a></li>
  <li><span class="separator">| </span><a href="describecomponents.cgi">Browse</a></li>
  <li><span class="separator">| </span><a href="query.cgi">Search</a></li>

  <li class="form">
    <span class="separator">| </span>
    <form action="buglist.cgi" method="get"
        onsubmit="if (this.quicksearch.value == '')
                  { alert('Please enter one or more search terms first.');
                    return false; } return true;">
    <input type="hidden" id="no_redirect_bottom" name="no_redirect" value="0">
    <script type="text/javascript">
      if (history && history.replaceState) {
        var no_redirect = document.getElementById("no_redirect_bottom");
        no_redirect.value = 1;
      }
    </script>
    <input class="txt" type="text" id="quicksearch_bottom" name="quicksearch" 
           title="Quick Search" value="">
    <input class="btn" type="submit" value="Search" 
           id="find_bottom"></form>
  <a href="page.cgi?id=quicksearch.html" title="Quicksearch Help">[?]</a></li>

  <li><span class="separator">| </span><a href="report.cgi">Reports</a></li>

  <li>
      <span class="separator">| </span>
        <a href="request.cgi">Requests</a></li>


  <li>
        <span class="separator">| </span>
        <a href="https://bugzilla.readthedocs.org/en/5.0/using/understanding.html" target="_blank">Help</a>
      </li>
    

    <li id="mini_login_container_bottom">
  <span class="separator">| </span>
  <a id="login_link_bottom" href="show_bug.cgi?id=16570&amp;GoAheadAndLogIn=1"
     onclick="return show_mini_login_form('_bottom')">Log In</a>

  <form action="show_bug.cgi?id=16570" method="POST"
        class="mini_login bz_default_hidden"
        id="mini_login_bottom">
    <input id="Bugzilla_login_bottom" required
           name="Bugzilla_login" class="bz_login"
        placeholder="Login">
    <input class="bz_password" name="Bugzilla_password" type="password"
           id="Bugzilla_password_bottom" required
           placeholder="Password">
    <input type="hidden" name="Bugzilla_login_token"
           value="">
    <input type="submit" name="GoAheadAndLogIn" value="Log in"
            id="log_in_bottom">
    <a href="#" onclick="return hide_mini_login_form('_bottom')">[x]</a>
  </form>
</li>
  <span class="separator">| </span>
  <li><a href="http://www.eclipse.org/legal/termsofuse.php">Terms of Use</a></li>
  <span class="separator">| </span>
  <li><a href="http://www.eclipse.org/legal/copyright.php">Copyright Agent</a></li>
</ul>
  </li>

  




  
</ul>

      <div class="outro"></div>
    </div>

  </body>
</html>